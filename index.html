
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Living life and make it better</title>
  <meta name="author" content="Endy Muhardin">

  
  <meta name="description" content="Walaupun sudah dibuatkan minibook, tapi ternyata ada juga beberapa orang yang tidak paham bagaimana cara enable/disable log message di aplikasi Java &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://endymuhardin.github.com/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="/javascripts/ender.js"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <link href="/atom.xml" rel="alternate" title="Living life and make it better" type="application/atom+xml">
  <link href='http://fonts.googleapis.com/css?family=Lato:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <div id="logo">
  	<div id="logoLeft">{</div>
  	<div id="logoText">endymuhardin</div>
  	<div id="logoRight">}</div>
  	<div class="clear"></div>
  </div>
  <h1><a href="/">Living life and make it better</a></h1>
  
    <h2>life, learn, contribute</h2>
  
  <div class="clear"></div>
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:endymuhardin.github.com" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <!-- Now we're back to normal posts. Note the links used under href in both headers.-->
        <h1 class="entry-title"><a href="/blog/Java/konsep-dasar-log4/">Konsep Dasar Log4j</a></h1>
      
    
    
      <p class="meta">
        








  


<time datetime="2012-07-30T20:59:00+07:00" pubdate data-updated="true">Jul 30<span>th</span>, 2012</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Walaupun sudah dibuatkan <a href="http://endy.artivisi.com/blog/java/menggunakan-log4j">minibook</a>, tapi ternyata ada juga beberapa orang yang tidak paham bagaimana cara enable/disable log message di aplikasi Java. Oleh karena itu, baiklah saya jelaskan lagi secara lebih singkat.</p>

<p>Ada beberapa komponen penting dalam aplikasi logging :</p>

<ul>
<li><p>logger : ini adalah yang kita gunakan di aplikasi untuk mengeluarkan pesan.
tadinya System.out.println(&#8220;Coba&#8221;);
diganti menjadi logger.info(&#8220;Coba&#8221;);</p></li>
<li><p>appender : komponen yang bertugas menampilkan log message
misalnya : console appender : menampilkan ke System.out
File appender : menulis log ke file
Rolling file appender : menulis ke file, lalu dirolling berdasarkan kriteria tertentu (size atau time)
misalnya, setelah mencapai 1 MB, tulis ke file berbeda, atau tiap 1 jam ganti file</p></li>
<li><p>category : ini adalah sumber log message, yaitu package atau realm.
<strong>biasanya</strong> category == package
Ini digunakan untuk memfilter log mana yang akan ditampilkan ke appender mana</p></li>
</ul>


<p>Selain 3 komponen itu, ada terminologi yang namanya level.
Contoh level : error, warn, info, debug, trace
Level ini berlaku bertingkat, jadi kalau kita bilang info, artinya info, warn, error.
Kalau kita bilang debug, maka hasilnya debug, info, warn, error.</p>

<p>Log message ditampilkan atau tidak, tergantung category dan level.</p>

<p>Contoh kasus :
Saya membuat aplikasi, berisi package com.artivisi.belajar.logging.
Isinya ada 2 class, Coba dan Halo.</p>

<p>Aplikasi saya ini menggunakan framework Spring, yang mana berisi package org.springframework, yang berisi banyak sub package, seperti org.springframework.core, org.springframework.jdbc, dsb.</p>

<p>Untuk source code yang saya tulis sendiri (Coba dan Halo), saya ingin menampilkan level debug, karena masih fase development. Nantinya kalau sudah production, cukup level warn saja yang ditampilkan.
Sedangkan untuk library Spring Framework, cukup level error saja yang ditampilkan.</p>

<p>Semua log message ditampilkan ke terminal, supaya mudah diamati.</p>

<p>Contoh kasus di atas, bila kita menggunakan log4j akan dikonfigurasi sebagai berikut :</p>

<div><script src='https://gist.github.com/3205393.js?file='></script>
<noscript><pre><code># by default, levelnya adalah INFO, tampilkan ke System.out
log4j.rootLogger=INFO,Konsole 

# untuk package com.artivisi, tampilkan level DEBUG ke System.out
log4j.logger.com.artivisi=DEBUG,Konsole

# untuk spring, error saja yang ditampilkan
log4j.logger.org.springframework=ERROR,Konsole

# Appender Konsole adalah System.out
log4j.appender.Konsole=org.apache.log4j.ConsoleAppender 
log4j.appender.Konsole.layout=org.apache.log4j.PatternLayout 
# Format tanggal menurut ISO­8601 : %d 
log4j.appender.Konsole.layout.ConversionPattern=%d [%t] %­5p %c ­ %m%n
</code></pre></noscript></div>


<p>Konfigurasi di atas harus dibuat dengan nama log4j.properties, dan diletakkan di dalam classpath. Kalau namanya tidak sama atau lokasinya salah, maka tidak akan dibaca oleh Log4J.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <!-- Now we're back to normal posts. Note the links used under href in both headers.-->
        <h1 class="entry-title"><a href="/blog/Java/monitoring-aplikasi-java/">Monitoring Aplikasi Java</a></h1>
      
    
    
      <p class="meta">
        








  


<time datetime="2012-07-28T20:45:07+07:00" pubdate data-updated="true">Jul 28<span>th</span>, 2012</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Setelah aplikasi kita selesai dibuat, langkah selanjutnya tentu saja adalah menjalankannya di server production. Dalam software development, ini disebut dengan transisi dari development menjadi operation.</p>

<p>Salah satu aspek penting dalam fase operation adalah monitoring performance. Monitoring dilakukan untuk berbagai tujuan, diantaranya :</p>

<ul>
<li><p>Mengetahui karakteristik aplikasi dalam menggunakan resource. Informasi ini bisa kita gunakan untuk melakukan tuning performance</p></li>
<li><p>Mengetahui karakteristik user dalam menggunakan aplikasi. Perilaku user ini berguna untuk menentukan waktu-waktu sibuk dan waktu-waktu idle, sehingga kita bisa melakukan capacity planning dengan akurat.</p></li>
<li><p>Mengetahui berapa persen resource yang sudah terpakai, sehingga kita punya gambaran kapan harus melakukan upgrade, dan apa yang harus diupgrade</p></li>
<li><p>Mendapatkan notifikasi secepat mungkin pada saat sistem mengalami gangguan</p></li>
</ul>


<p>Pada umumnya, monitoring dilakukan dengan memantau bagian-bagian dalam sistem, diantaranya :</p>

<ul>
<li><p>Dalam sistem operasi</p>

<ul>
<li><p>Jumlah proses</p></li>
<li><p>CPU</p></li>
<li><p>Memori</p></li>
<li><p>Disk I/O</p></li>
<li><p>Network I/O</p></li>
</ul>
</li>
<li><p>Dalam aplikasi</p>

<ul>
<li><p>Jumlah thread</p></li>
<li><p>Alokasi memori</p></li>
<li><p>Class/method yang mengkonsumsi resource terbesar</p></li>
<li><p>Class/method yang memakan waktu lama</p></li>
<li><p>Untuk bahasa pemrograman yang berjalan di virtual machine (seperti Java, .NET, Ruby, dsb), kita juga perlu memantau perilaku Garbage Collector</p></li>
</ul>
</li>
<li><p>Database Server</p>

<ul>
<li><p>Jumlah koneksi yang dibuka baik yang idle maupun yang aktif</p></li>
<li><p>Query yang memakan waktu lama</p></li>
<li><p>Tabel yang sering diakses</p></li>
</ul>
</li>
</ul>


<p>Dalam melakukan monitoring, ada banyak tools yang digunakan. Beberapa aplikasi opensource yang populer diantaranya :</p>

<ul>
<li><p>Nagios</p></li>
<li><p>Icinga : ini adalah fork dari Nagios</p></li>
<li><p>Zenoss</p></li>
<li><p>Zabbix</p></li>
<li><p>OpenNMS</p></li>
<li><p>Hyperic</p></li>
</ul>


<p>Pada umumnya, semua aplikasi di atas memiliki fitur yang mirip-mirip, yaitu :</p>

<ul>
<li><p>SNMP Monitoring. SNMP adalah protokol yang populer, tersedia di sistem operasi, network hardware (switch, router, dsb), bahkan aplikasi (Java VM, database server, dsb)</p></li>
<li><p>JMX Monitoring. JMX adalah protokol untuk memonitor aplikasi Java. Dengan menggunakan JMX, informasi yang diperoleh akan lebih rinci.</p></li>
<li><p>Agent dan Agentless Monitoring. Agent adalah aplikasi kecil yang diinstal di server yang ingin dimonitor. Dengan agent, informasi yang dikumpulkan bisa lebih detail. Di lain sisi, tidak semua tempat bisa dipasangi agent (misalnya router). Umumnya aplikasi monitoring mendukung monitoring dengan agent maupun tanpa agent.</p></li>
</ul>


<p>Cara instalasi dari aplikasi di atas bisa dibaca di websitenya masing-masing. Yang akan kita bahas di sini adalah cara konfigurasi aplikasi Java, khususnya yang menggunakan framework Spring dan Hibernate, agar bisa dimonitor oleh aplikasi-aplikasi di atas.</p>

<p>Pada prinsipnya, berikut adalah hal-hal yang perlu dilakukan :</p>

<ol>
<li><p>Menentukan metric atau jenis data yang akan dimonitor</p></li>
<li><p>Mengaktifkan MBean agar metric tersebut dipublish melalui JMX</p></li>
<li><p>Mengaktifkan JMX server agar bisa dihubungi dari aplikasi monitoring</p></li>
</ol>


<p>Aplikasi yang akan kita jadikan contoh kasus adalah template standar aplikasi web ArtiVisi, yang <a href="https://github.com/endymuhardin/belajar-restful">source codenya tersedia di Github</a>.</p>

<h2>Menentukan metric</h2>

<p>Beda jenis datanya, tentu beda juga cara pengumpulan data dan tools yang digunakan untuk mengolahnya.</p>

<h3>Tabel Metrik dan Tools</h3>

<table>
<thead>
<tr>
<th>Metric      </th>
<th> Metode Pengumpulan </th>
<th> Tools</th>
</tr>
</thead>
<tbody>
<tr>
<td>CPU         </td>
<td> SNMP atau Agent    </td>
<td> Nagios,Zenoss,dkk</td>
</tr>
<tr>
<td>Memori      </td>
<td> SNMP atau Agent    </td>
<td> Nagios,Zenoss,dkk</td>
</tr>
<tr>
<td>Disk IO     </td>
<td> SNMP atau Agent    </td>
<td> Nagios,Zenoss,dkk</td>
</tr>
<tr>
<td>Network     </td>
<td> SNMP atau Agent    </td>
<td> Nagios,Zenoss,dkk</td>
</tr>
<tr>
<td>Tomcat      </td>
<td> JMX                </td>
<td> Hyperic</td>
</tr>
<tr>
<td>MySQL       </td>
<td> Agent              </td>
<td> Hyperic</td>
</tr>
<tr>
<td>Spring      </td>
<td> AOP                </td>
<td> Javamelody</td>
</tr>
<tr>
<td>Hibernate   </td>
<td> JMX                </td>
<td> Hyperic</td>
</tr>
</tbody>
</table>


<h2>Monitoring dengan JavaMelody</h2>

<p>Untuk mengaktifkan monitoring menggunakan JavaMelody, ada beberapa langkah yang perlu kita lakukan, yaitu :</p>

<ol>
<li>Menambahkan jar JavaMelody</li>
<li>Memasang AOP interceptor supaya bisa memonitor beans dalam Spring</li>
<li>Mengaktifkan monitoring JavaMelody</li>
</ol>


<p>Karena projectnya menggunakan Maven, maka menambahkan jar sangat mudah, cukup dengan menambahkan dependency sebagai berikut :</p>

<div><script src='https://gist.github.com/3192086.js?file=pom.xml'></script>
<noscript><pre><code>&lt;dependency&gt;
    &lt;groupId&gt;net.bull.javamelody&lt;/groupId&gt;
    &lt;artifactId&gt;javamelody-core&lt;/artifactId&gt;
    &lt;version&gt;1.39.0&lt;/version&gt;
&lt;/dependency&gt;</code></pre></noscript></div>


<p>Selanjutnya, kita memasang interceptor supaya object yang kita buat dimonitor oleh JavaMelody. Biasanya kita memonitor implementasi proses bisnis. Berikut konfigurasi applicationContext.xml</p>

<div><script src='https://gist.github.com/3192086.js?file=applicationContext.xml'></script>
<noscript><pre><code>&lt;bean id=&quot;facadeMonitoringAdvisor&quot; 
      class=&quot;net.bull.javamelody.MonitoringSpringAdvisor&quot;&gt;
    &lt;property name=&quot;pointcut&quot;&gt;
        &lt;bean class=&quot;net.bull.javamelody.MonitoredWithInterfacePointcut&quot;&gt;
            &lt;property name=&quot;interfaceName&quot;
                      value=&quot;com.artivisi.belajar.restful.service.MonitoredService&quot; 
                    /&gt;
        &lt;/bean&gt;
    &lt;/property&gt;
&lt;/bean&gt;</code></pre></noscript></div>


<p>Terakhir, kita aktifkan JavaMelody. Karena aplikasinya adalah aplikasi web, maka inisialisasi dilakukan di dalam file web.xml sebagai berikut</p>

<div><script src='https://gist.github.com/3192086.js?file=web.xml'></script>
<noscript><pre><code>&lt;context-param&gt;
    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
    &lt;param-value&gt;
        classpath:net/bull/javamelody/monitoring-spring.xml
        classpath*:com/artivisi/**/applicationContext.xml
    &lt;/param-value&gt;
&lt;/context-param&gt;

&lt;listener&gt;
    &lt;listener-class&gt;net.bull.javamelody.SessionListener&lt;/listener-class&gt;
&lt;/listener&gt;

&lt;!-- Monitor aplikasi menggunakan javamelody --&gt;
&lt;filter&gt;
    &lt;filter-name&gt;monitoring&lt;/filter-name&gt;
    &lt;filter-class&gt;net.bull.javamelody.MonitoringFilter&lt;/filter-class&gt;
&lt;/filter&gt;
&lt;filter-mapping&gt;
    &lt;filter-name&gt;monitoring&lt;/filter-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;</code></pre></noscript></div>


<p>Setelah selesai, kita bisa jalankan aplikasi seperti biasa. Untuk mengakses hasil monitoring, kita dapat mengakses url http://host:port/context-aplikasi/monitoring.</p>

<p>Berikut adalah screenshotnya.</p>

<p><a href="http://endy.artivisi.com/blog/wp-content/uploads/2012/07/JavaMelody-Charts.png"><img src="http://endy.artivisi.com/blog/wp-content/uploads/2012/07/JavaMelody-Charts.png" alt="JavaMelody-Charts" /></a></p>

<h2>Mengaktifkan MBean</h2>

<p>Selain menggunakan JavaMelody, kita juga bisa melakukan monitoring menggunakan JMX. Beruntung kita yang menggunakan Spring, JMX akan sangat mudah dikonfigurasi. Pada contoh berikut, kita akan mengaktifkan monitoring terhadap statistik Hibernate. Langkah-langkahnya adalah sebagai berikut :</p>

<ol>
<li>Mengaktifkan fitur statistik dalam Hibernate</li>
<li>Mendeklarasikan MBean untuk memonitor statistik Hibernate</li>
<li>Menginstankan JMX server (MBean Server)</li>
</ol>


<p>Aktifasi fitur statistik dalam Hibernate dilakukan dengan mengisi nilai true pada variabel konfigurasi hibernate.generate_statistics, sebagai berikut :</p>

<div><script src='https://gist.github.com/3192099.js?file=hibernate-statistics.xml'></script>
<noscript><pre><code>&lt;bean id=&quot;sessionFactory&quot;
    class=&quot;org.springframework.orm.hibernate4.LocalSessionFactoryBean&quot;
    p:dataSource-ref=&quot;dataSource&quot;&gt;
    &lt;property name=&quot;hibernateProperties&quot;&gt;
        &lt;props&gt;
            &lt;prop key=&quot;hibernate.generate_statistics&quot;&gt;true&lt;/prop&gt;
        &lt;/props&gt;
    &lt;/property&gt;
    &lt;property name=&quot;packagesToScan&quot; value=&quot;com.artivisi.belajar.restful.domain&quot; /&gt;
&lt;/bean&gt;</code></pre></noscript></div>


<p>Selanjutnya, statistik yang telah dihitung ini dipublish menggunakan MBean.</p>

<div><script src='https://gist.github.com/3192099.js?file=hibernateMBean.xml'></script>
<noscript><pre><code>&lt;bean id=&quot;hibernateStatisticsMBean&quot; class=&quot;org.hibernate.jmx.StatisticsService&quot;&gt;
    &lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot; /&gt;
&lt;/bean&gt;</code></pre></noscript></div>




<div><script src='https://gist.github.com/3192099.js?file=mbeanExporter.xml'></script>
<noscript><pre><code>&lt;bean id=&quot;mbeanExporter&quot; class=&quot;org.springframework.jmx.export.MBeanExporter&quot;&gt;
  &lt;property name=&quot;beans&quot;&gt;
    &lt;map&gt;
      &lt;entry 
        key=&quot;SpringBeans:name=hibernateStatisticsMBean&quot; 
        value-ref=&quot;hibernateStatisticsMBean&quot; /&gt;
    &lt;/map&gt;
  &lt;/property&gt;
&lt;/bean&gt;</code></pre></noscript></div>


<p>Terakhir, kita sediakan MBean Server untuk menjalankan MBean yang sudah kita deklarasikan di atas. Spring sudah memudahkan konfigurasinya dengan namespace yang baru</p>

<div><script src='https://gist.github.com/3192099.js?file=mbean-server.xml'></script>
<noscript><pre><code>&lt;context:mbean-server/&gt;</code></pre></noscript></div>


<p>Selanjutnya, jalankan aplikasi kita seperti biasa di Tomcat, Jetty, dsb.
Setelah aplikasi berjalan, kita dapat melihatnya menggunakan JConsole.</p>

<p>Jalankan JConsole, dan pilih proses yang akan dimonitor.</p>

<p><a href="http://endy.artivisi.com/blog/wp-content/uploads/2012/07/jconsole-select-pid.png"><img src="http://endy.artivisi.com/blog/wp-content/uploads/2012/07/jconsole-select-pid.png" alt="jconsole-select-pid" /></a></p>

<p>Tampilkan MBean Hibernate Statistics</p>

<p><a href="http://endy.artivisi.com/blog/wp-content/uploads/2012/07/jconsole-hibernate-statistics.png"><img src="http://endy.artivisi.com/blog/wp-content/uploads/2012/07/jconsole-hibernate-statistics.png" alt="jconsole-hibernate-statistics" /></a></p>

<p>Kita bisa lihat bahwa statistik Hibernate sudah dapat diakses. Informasi ini juga bisa ditampilkan di aplikasi monitoring seperti OpenNMS, Hyperic, dan aplikasi lain yang support JMX.</p>

<p>Selain itu, kalau kita sudah mengaktifkan JavaMelody seperti dijelaskan di atas, MBean ini juga bisa ditampilkan di url yang sama seperti screenshot di bawah</p>

<p><a href="http://endy.artivisi.com/blog/wp-content/uploads/2012/07/javamelody-mbeans.png"><img src="http://endy.artivisi.com/blog/wp-content/uploads/2012/07/javamelody-mbeans.png" alt="javamelody-mbeans" /></a></p>

<h2>Kesimpulan</h2>

<p>Demikianlah hasil oprek-oprek sambil menunggu motor servis rutin. Dengan beberapa langkah sederhana, kita dapat memperoleh informasi lengkap tentang apa yang terjadi di aplikasi kita. Informasi ini selanjutnya dapat dijadikan pedoman untuk melakukan tuning performance. Selain itu, dengan menggunakan aplikasi pengolah data seperti <a href="http://code.google.com/p/rocksteady/">Rocksteady</a>, kita dapat membuat early warning system, yaitu suatu sistem yang dapat memprediksi terjadinya bencana dan memberikan notifikasi, sehingga kita bisa melakukan antisipasi.</p>

<h2>Referensi</h2>

<ul>
<li><p><a href="http://www.oracle.com/technetwork/java/javase/tech/javamanagement-140525.html">JMX Homepage</a></p></li>
<li><p><a href="http://visualvm.java.net/">VisualVM Homepage</a></p></li>
<li><p><a href="http://java.sun.com/developer/technicalArticles/J2SE/jconsole.html">Cara menggunakan JConsole</a></p></li>
<li><p><a href="http://dzone.com/snippets/spring-jmx-sample">Cara konfigurasi Spring dan Hibernate</a></p></li>
<li><p><a href="http://nurkiewicz.blogspot.com/2011/03/jolokia-highcharts-jmx-for-human-beings.html">Menampilkan data dari JMX dengan Jolokia</a></p></li>
</ul>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <!-- Now we're back to normal posts. Note the links used under href in both headers.-->
        <h1 class="entry-title"><a href="/blog/Linux/backup-home-folder/">Backup Home Folder</a></h1>
      
    
    
      <p class="meta">
        








  


<time datetime="2011-08-26T23:00:29+07:00" pubdate data-updated="true">Aug 26<span>th</span>, 2011</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Seberapa penting file di komputer kita? Tentu tidak ternilai harganya. Tapi apakah kita melakukan backup secara terhadap file-file di komputer kita? Beberapa menit yang lalu, saya menjawab tidak untuk pertanyaan tersebut.</p>

<p>Kenapa backup tidak dilakukan? Penyebab utamanya biasanya adalah karena merepotkan. Kita harus pilih file yang mau dibackup, membuka aplikasi backup, lalu menjalankannya. Walaupun cuma butuh waktu beberapa menit, tapi biasanya kita sering menunda dan akhirnya lupa.</p>

<p>Cara paling efektif untuk melakukan backup rutin adalah dengan mengotomasinya. Effort untuk melakukan setup cukup sekali saja, selanjutnya backup akan berjalan otomatis tanpa kita sadari. Pada artikel ini, saya akan posting teknik backup yang saya gunakan.</p>

<p>Sebelum kita mulai, terlebih dulu kita tentukan requirementnya, supaya jelas apa yang kita ingin capai. Saya ingin membackup folder tertentu di komputer saya (misalnya <em>/home/endy</em> dan <em>/opt/multimedia/Photos</em>). Backup ini dilakukan secara rutin (misalnya satu jam sekali, satu hari sekali, atau satu minggu sekali). Selain rutin, juga harus incremental. Artinya kalau saya punya backup hari ini jam 11, maka backup selanjutnya di jam 12 hanya menyimpan file yang berubah saja. Dengan demikian, saya bisa jalankan backupnya satu jam sekali dan tidak akan menyebabkan harddisk menjadi penuh dalam beberapa jam saja.</p>

<p>Kalau kita cari di Google dengan keyword <em>ubuntu backup application</em>, ada banyak sekali aplikasi backup yang tersedia.
Ada Unison, Bacula, SBackup, rdiff-backup, Deja Dup, dan <a href="http://davestechshop.net/ListOfFreeOpenSourceLinuxUbuntuBackupSoftware">entah apa lagi</a>. Walaupun demikian, seperti biasanya, saya akan gunakan aplikasi yang paling populer, universal (ada di mana-mana), dan bisa dijalankan dari command line (supaya bisa diotomasi dengan cron). Pilihannya tentu adalah <em>rsync</em>.</p>

<p><em>rsync</em> adalah aplikasi untuk melakukan file transfer. Dia memiliki beberapa kelebihan, diantaranya :</p>

<ul>
<li><p>tersedia di semua *nix (misalnya Linux dan Mac)</p></li>
<li><p>berbasis command line, sehingga bisa saya aplikasikan juga di server</p></li>
<li><p>sudah teruji kehandalannya</p></li>
<li><p>bisa resume (bila transfer putus di tengah jalan, tidak perlu ulang dari awal)</p></li>
<li><p>data yang ditransfer bisa dikompres, supaya lebih cepat</p></li>
<li><p>bisa mengirim data melalui ssh, sehingga keamanan data terjamin</p></li>
<li><p>memiliki kemampuan hard linking sehingga bisa menghemat space (akan dijelaskan lebih lanjut)</p></li>
</ul>


<p>With great power, comes great complexity. Demikian kata pamannya Spiderman seandainya dia harus menggunakan <em>rsync</em>. Saking banyaknya opsi, sehingga kita bingung apa yang harus dipakai. Berikut adalah opsi rsync yang saya gunakan :</p>

<ul>
<li><p>a : archive. Opsi ini sama dengan kalau kita mengaktifkan opsi rlptgoD</p></li>
<li><p>r : rekursif sampai ke subfolder terdalam</p></li>
<li><p>l : symlink tetap dicopy sebagai symlink</p></li>
<li><p>p : file permission disamakan dengan aslinya</p></li>
<li><p>t : modification time (waktu terakhir update) disamakan dengan aslinya</p></li>
<li><p>g : kepemilikan group disamakan dengan aslinya</p></li>
<li><p>o : kepemilikan owner disamakan dengan aslinya</p></li>
<li><p>D : file device dan special disamakan dengan aslinya</p></li>
<li><p>force : folder kosong di tujuan dihapus walaupun ada isinya</p></li>
<li><p>ignore-errors : lanjut terus walaupun ada error</p></li>
<li><p>exclude-from : file text berisi daftar file/folder yang tidak perlu ditransfer</p></li>
<li><p>link-dest : lihat ke folder yang disebutkan, kalau ada file yang sama, buat hard link</p></li>
</ul>


<p>Pada penjelasan di atas, beberapa kali disebutkan istilah hard-link. Di Linux, suatu file terdiri dari dua bagian : isi (content), dan nama. Satu content yang sama bisa saja memiliki dua nama yang berbeda di folder berbeda sehingga terlihat seolah-olah ada dua file.
Misalnya, kita memiliki file bernama <em>coba.txt</em>. Ini artinya, ada satu content dan satu nama file coba.txt. Kita bisa membuat nama file baru yang isinya sama dengan perintah sebagai berikut</p>

<p><em>__ln coba.txt halo.txt</em></p>

<p>Perintah di atas akan membentuk file <em>halo.txt</em> yang isinya sama dengan <em>coba.txt</em>. Kalau kita edit <em>coba.txt</em>, maka isi file <em>halo.txt</em> juga akan berubah, karena mereka sebetulnya menunjuk ke benda yang sama.</p>

<p>Dengan menggunakan hard-link ini, kita bisa menduplikasi file tanpa menduplikasi space di harddisk. Ini akan sangat berguna untuk membuat incremental backup, karena kita bisa membuat backup sesering mungkin tanpa memenuhi isi harddisk.</p>

<p>Fitur ini kita gunakan pada <em>rsync</em> dengan opsi <em>link-dest</em>. Sebagai contoh, kita jalankan backup pertama kali dan menghasilkan folder <em>20110826-1100</em>. Pada waktu kita jalankan backup kedua, kita berikan opsi <em>link-dest=20110826-1100</em>. Saat akan mengisi folder yang baru (misalnya <em>20110826-1200</em>), <em>rsync</em> akan melihat ke folder <em>20110826-1100</em> dan memeriksa apakah file yang sama sudah ada. Bila sudah ada, maka <em>rsync</em> tidak akan menulis file baru, melainkan hanya akan membuat hard-link saja. Jadi, bila backup pertama berisi 100 file dengan total 10 GB, dan backup kedua berisi 99 file yang sama, dan 1 file saja yang berubah dengan ukuran 1 GB, maka total space yang terpakai adalah 10 GB (backup pertama) dan 1 GB (backup kedua), bukannya 20 GB.</p>

<p>Setelah kita memahami opsi <em>rsync</em>, berikut adalah perintah yang kita gunakan</p>

<div><script src='https://gist.github.com/1172978.js?file=rsync-cmd.txt'></script>
<noscript><pre><code>rsync -a --force --ignore-errors --exclude-from=rsync-exclude.txt --link-dest=folder-backup-sebelumnya SRC DEST</code></pre></noscript></div>


<p>File <em>rsync-exclude.txt</em> berisi folder yang tidak dibackup, punya saya isinya seperti ini :</p>

<div><script src='https://gist.github.com/1172978.js?file=rsync-exclude.txt'></script>
<noscript><pre><code>#rsync script exclude file
**/.thumbnails/
**/Desktop/Trash/
**/.cache/
**/.m2/
**/.metadata/
**/.netbeans/
**/.shotwell/
**/.config/
**/.gconf/
**/virtual-machines/</code></pre></noscript></div>


<p><em>folder-backup-sebelumnya</em> perlu dihitung dulu. Caranya menggunakan perintah <em>ls -tr</em> yang akan menampilkan isi folder yang diurutkan berdasarkan modification time secara descending. Berikut contoh outputnya.</p>

<div><script src='https://gist.github.com/1172978.js?file=ls-ltr-output'></script>
<noscript><pre><code>ls -ltr /opt/downloads/backups/
total 12
drwxr-xr-x 3 endy endy 4096 2011-08-26 13:21 20110826-1321
drwxr-xr-x 3 endy endy 4096 2011-08-26 14:07 20110826-1407
drwxr-xr-x 3 endy endy 4096 2011-08-26 14:27 20110826-1427</code></pre></noscript></div>


<p>Dari sini, kita cukup ambil yang paling atas menggunakan perintah <em>tail -1</em></p>

<div><script src='https://gist.github.com/1172978.js?file=ls-ltr-tail'></script>
<noscript><pre><code>ls -tr /opt/downloads/backups/ | tail -1
20110826-1427</code></pre></noscript></div>


<p>Dengan bermodalkan pengetahuan tersebut, kita bisa membuat script seperti ini.</p>

<div><script src='https://gist.github.com/1172978.js?file=rsync-backup.sh'></script>
<noscript><pre><code>#!/usr/bin/env bash

# run hourly with cron
# 0 * * * * /path/ke/rsync-backup.sh /home/endy /opt/downloads/backups /path/ke/rsync-exclude.txt

SRC=$1
DEST=$2
EXCLUDES=$3
args=(&quot;$@&quot;);
MORE_OPTS=${args[@]:3}

if [ &quot;$#&quot; -lt 3 ]; then
    echo &quot;Usage : $0 &lt;src&gt; &lt;dest&gt; &lt;exclude list&gt; [rsync options]&quot;
    return 1
fi


LAST=$(ls -tr $DEST | tail -1)
if [ &quot;$LAST&quot; != &quot;&quot; ]; then
        LINK=&quot;--link-dest=$DEST/$LAST&quot;
fi

OPTS=&quot; -a --force --ignore-errors --exclude-from=$EXCLUDES $LINK&quot;

# echo OPTS $OPTS MORE_OPTS $MORE_OPTS

rsync $OPTS $MORE_OPTS $SRC $DEST/$(date +%Y%m%d-%H%M)</code></pre></noscript></div>


<p>Untuk membackup folder <em>/home/endy</em> ke folder <em>/opt/downloads/backups</em>, kita jalankan seperti ini :</p>

<div><script src='https://gist.github.com/1172978.js?file=exec-backup.sh'></script>
<noscript><pre><code>./rsync-backup-home.sh /home/endy /opt/downloads/backups rsync-exclude.txt</code></pre></noscript></div>


<p>Selanjutnya, kita bisa pasang di crontab dengan setting seperti ini, supaya dijalankan tiap tiga jam.</p>

<div><script src='https://gist.github.com/1172978.js?file=crontab.txt'></script>
<noscript><pre><code>0 */3 * * * /path/ke/rsync-backup-home.sh /home/endy /opt/downloads/backups /path/ke/rsync-exclude.txt</code></pre></noscript></div>


<p>Voila &#8230; folder home kita sudah terbackup secara otomatis tanpa kita sadari. Sepanjang menulis artikel ini, laptop saya sudah membackup dirinya sendiri sebanyak 3 kali :D</p>

<p>Setelah membuat backup di harddisk laptop, tentunya kita ingin memindahkannya ke external harddisk supaya kita bisa mengosongkan lokasi backup di laptop.</p>

<p>Berikut adalah perintah rsync yang digunakan.</p>

<div><script src='https://gist.github.com/1172978.js?file=copy-backup-to-external.sh'></script>
<noscript><pre><code>rsync -avzPH /opt/downloads/backups /media/DATA2/</code></pre></noscript></div>


<p>Dan ini adalah penjelasan terhadap opsi yang digunakan:</p>

<ul>
<li><p>P : sama dengan partial dan progress</p></li>
<li><p>partial : file yang baru dicopy sebagian tetap disimpan agar bisa diresume</p></li>
<li><p>progress : menampilkan progress report</p></li>
<li><p>H : hard link dicopy sebagai hard link juga. Tanpa opsi ini, tiap hard link akan dibuatkan file baru sehingga boros space harddisk</p></li>
</ul>


<p>Perintah untuk transfer ke external harddisk ini tidak saya jalankan secara otomatis via cron, karena harddisknya belum tentu terpasang.</p>

<p>Demikianlah artikel tentang backup rutin. Mudah-mudahan kita semua bisa terhindar dari musibah harddisk.</p>

<h3>Referensi</h3>

<ul>
<li><p><a href="http://www.mikerubel.org/computers/rsync_snapshots">Easy Automated Snapshot-Style Backups with Linux and Rsync</a></p></li>
<li><p><a href="http://www.hermann-uwe.de/blog/simple-backups-using-rsync">Simple backup using rsync</a></p></li>
<li><p><a href="http://rsync.samba.org/examples.html">rsync examples</a></p></li>
</ul>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <!-- Now we're back to normal posts. Note the links used under href in both headers.-->
        <h1 class="entry-title"><a href="/blog/Java/Manajemen/staged-deployment/">Staged Deployment</a></h1>
      
    
    
      <p class="meta">
        








  


<time datetime="2011-08-16T15:57:35+07:00" pubdate data-updated="true">Aug 16<span>th</span>, 2011</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Staged Deployment</p>

<p>Pada waktu kita coding, tentunya kita melakukan test terhadap kode program yang kita tulis. Kita jalankan langkah-langkah sesuai yang telah didefinisikan dalam test scenario. Setelah test di komputer kita sendiri (local) selesai dilakukan, tentunya kode program tersebut tidak langsung kita deploy ke production. Best practicesnya adalah, kita deploy aplikasinya ke server testing untuk kemudian ditest oleh Software Tester. Barulah setelah dinyatakan OK oleh tester, aplikasi versi terbaru tersebut kita deploy ke production.</p>

<p>Dengan demikian, kita memiliki tiga deployment environment, yaitu :</p>

<ul>
<li><p>development (komputer si programmer)</p></li>
<li><p>testing (test server)</p></li>
<li><p>production (live system)</p></li>
</ul>


<p>Environment ini bisa lebih banyak lagi kalau aplikasi kita harus dites kompatibilitasnya dengan berbagai hardware atau sistem operasi.</p>

<p>Cara kerja seperti ini disebut dengan istilah staged deployment atau deployment bertahap. Dengan menggunakan staged deployment, kita mencegah terjadinya bug fatal di production/live system.</p>

<p>Tantangan yang kita hadapi adalah, bagaimana cara mengelola konfigurasi aplikasi kita sehingga bisa dideploy di berbagai environment secara baik. Teknik bagaimana cara melakukan ini berbeda-beda, tergantung bahasa pemrograman, framework, dan library yang kita gunakan.</p>

<p>Pada artikel ini, kita akan membahas cara mengelola konfigurasi deployment menggunakan <a href="http://endy.artivisi.com/blog/java/development-stack-2011/">teknologi yang biasa digunakan di ArtiVisi</a>, yaitu<a href="http://www.springframework.org">Spring Framework</a> dan <a href="logback.qos.ch">Logback</a>.</p>

<h2>Alternatif Solusi</h2>

<p>Manajemen konfigurasi ini bisa kita lakukan dengan dua pendekatan, yaitu dikelola dengan <a href="http://maven.apache.org/guides/introduction/introduction-to-profiles.html">Maven Profile</a>, atau dengan konfigurasi Spring Framework.</p>

<p>Jika kita menggunakan Maven Profile, kita menambahkan opsi pada saat melakukan build, kira-kira seperti ini :</p>

<div><script src='https://gist.github.com/1134126.js?file=maven-profile.sh'></script>
<noscript><pre><code>mvn -P production clean install</code></pre></noscript></div>


<p>atau</p>

<div><script src='https://gist.github.com/1134126.js?file=maven-env-var.sh'></script>
<noscript><pre><code>mvn -Denv=production clean install</code></pre></noscript></div>


<p>Dalam konfigurasi profile, kita bisa memilih file mana yang akan diinclude di dalam hasil build. Hasilnya, kita bisa menghasilkan artifact yang berbeda tergantung dari opsi yang kita berikan pada saat build.</p>

<p>Walaupun demikian, berdasarkan hasil Googling, ternyata <a href="http://java.dzone.com/articles/maven-profile-best-practices">metode ini tidak direkomendasikan</a>. Justru konfigurasi melalui Spring lebih disarankan.</p>

<p>Dengan menggunakan konfigurasi Spring, artifact yang dihasilkan oleh build hanya satu jenis saja. Artifact ini berisi semua pilihan konfigurasi. Konfigurasi mana yang akan aktif pada saat dijalankan (runtime) akan ditentukan oleh setting environment variable, bukan oleh artifactnya.</p>

<p>Selanjutnya, kita akan membahas metode manajemen konfigurasi menggunakan Spring.</p>

<h2>Konfigurasi Database</h2>

<p>Konfigurasi yang biasanya berbeda adalah informasi koneksi database. Untuk membedakan masing-masing environment, kita akan membuat tiga file, yaitu:</p>

<ul>
<li><p>jdbc.properties : digunakan di laptop programmer</p></li>
<li><p>jdbc.testing.properties : digunakan di server test</p></li>
<li><p>jdbc.production.properties : digunakan di live</p></li>
</ul>


<p>Berikut contoh isi jdbc.properties, yaitu konfigurasi koneksi database di laptop saya :</p>

<div><script src='https://gist.github.com/1134126.js?file=jdbc.properties'></script>
<noscript><pre><code>hibernate.dialect = org.hibernate.dialect.MySQL5InnoDBDialect
jdbc.driver = com.mysql.jdbc.Driver
jdbc.url = jdbc:mysql://localhost/kasbon?zeroDateTimeBehavior=convertToNull
jdbc.username = kasbon
jdbc.password = kasbon</code></pre></noscript></div>


<p>Kemudian, ini file jdbc.testing.properties :</p>

<div><script src='https://gist.github.com/1134126.js?file=jdbc.testing.properties'></script>
<noscript><pre><code>hibernate.dialect = org.hibernate.dialect.MySQL5InnoDBDialect
jdbc.driver = com.mysql.jdbc.Driver
jdbc.url = jdbc:mysql://localhost/kasbon_testing?zeroDateTimeBehavior=convertToNull
jdbc.username = root
jdbc.password = admin</code></pre></noscript></div>


<p>Perhatikan bahwa informasi nama database, username, dan password databasenya berbeda dengan yang ada di konfigurasi laptop.</p>

<p>Terakhir, jdbc.production.properties</p>

<div><script src='https://gist.github.com/1134126.js?file=jdbc.production.properties'></script>
<noscript><pre><code>hibernate.dialect = org.hibernate.dialect.MySQL5InnoDBDialect
jdbc.driver = com.mysql.jdbc.Driver
jdbc.url = jdbc:mysql://localhost/kasbon_live?zeroDateTimeBehavior=convertToNull
jdbc.username = root
jdbc.password = admin</code></pre></noscript></div>


<p>Ketiga file konfigurasi ini akan dibaca oleh konfigurasi Spring, yaitu di file applicationContext.xml. Isi lengkap dari file ini adalah sebagai berikut.</p>

<div><script src='https://gist.github.com/1134126.js?file=applicationContext.xml'></script>
<noscript><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
    xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd
        http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt;

    &lt;context:property-placeholder location=&quot;
    classpath*:jdbc.properties,
    classpath*:jdbc.${stage}.properties
    &quot; /&gt;

    &lt;tx:annotation-driven /&gt;

    &lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot;
        destroy-method=&quot;close&quot; p:driverClassName=&quot;${jdbc.driver}&quot; p:url=&quot;${jdbc.url}&quot;
        p:username=&quot;${jdbc.username}&quot; p:password=&quot;${jdbc.password}&quot; p:maxWait=&quot;40000&quot;
        p:maxActive=&quot;80&quot; p:maxIdle=&quot;20&quot; /&gt;

    &lt;bean id=&quot;transactionManager&quot;
        class=&quot;org.springframework.orm.hibernate3.HibernateTransactionManager&quot;
        p:sessionFactory-ref=&quot;sessionFactory&quot; /&gt;


    &lt;bean id=&quot;sessionFactory&quot;
        class=&quot;org.springframework.orm.hibernate3.annotation.AnnotationSessionFactoryBean&quot;
        p:dataSource-ref=&quot;dataSource&quot; p:configLocations=&quot;classpath*:com/artivisi/**/hibernate.cfg.xml&quot;&gt;
        &lt;property name=&quot;hibernateProperties&quot;&gt;
            &lt;props&gt;
                &lt;prop key=&quot;hibernate.dialect&quot;&gt;${hibernate.dialect}&lt;/prop&gt;
            &lt;/props&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

    &lt;bean id=&quot;messageSource&quot;
        class=&quot;org.springframework.context.support.ResourceBundleMessageSource&quot;&gt;
        &lt;property name=&quot;basenames&quot;&gt;
            &lt;list&gt;
                &lt;value&gt;messages&lt;/value&gt;
            &lt;/list&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

&lt;/beans&gt;</code></pre></noscript></div>


<p>Untuk lebih spesifik, konfigurasinya ada di baris berikut</p>

<div><script src='https://gist.github.com/1134126.js?file=context-loading.xml'></script>
<noscript><pre><code>&lt;context:property-placeholder location=&quot;
    classpath*:jdbc.properties, 
    classpath*:jdbc.${stage}.properties
&quot; /&gt;</code></pre></noscript></div>


<p>Di sana kita melihat ada variabel ${stage}.
Variabel ${stage} ini akan dicari dari <a href="http://static.springsource.org/spring/docs/3.0.x/spring-framework-reference/html/beans.html#beans-factory-xml-import">beberapa tempat, diantaranya environment variabel yang bisa diset di JVM ataupun di sistem operasi</a>. Cara mengeset variabel ${stage} akan kita bahas sebentar lagi.</p>

<p>Di situ kita menyuruh Spring untuk membaca file jdbc.properties dan jdbc.${stage}.properties. Jika ada nilai variabel yang sama (misalnya jdbc.username), maka nilai variabel di file yang disebutkan belakangan akan menimpa nilai yang didefinisikan file di atasnya.</p>

<p>Contohnya, misalnya variabel ${stage} nilainya adalah testing. Maka Spring akan membaca file jdbc.properties dan jdbc.testing.properties. Karena kedua file memiliki variabel jdbc.url, maka isi jdbc.url di file jdbc.testing.properties akan menimpa nilai jdbc.url di jdbc.properties.</p>

<p>Bila variabel ${stage} tidak ada isinya, Spring akan mencari file yang namanya jdbc.${stage}.properties, dan tidak akan ketemu. Dengan demikian, nilai yang digunakan adalah yang ada di jdbc.properties.</p>

<p>Dengan demikian, behavior aplikasi adalah sebagai berikut</p>

<blockquote><p>Bila variabel stage diset production atau testing, maka yang digunakan adalah nilai konfigurasi di jdbc.production.properties atau jdbc.testing.properties. Bila tidak diset atau diset selain itu, maka yang digunakan adalah konfigurasi di jdbc.properties</p></blockquote>

<p>Behavior seperti inilah yang kita inginkan. Selanjutnya, tinggal kita isi nilai variabel stage.</p>

<h2>Setting Environment Variabel</h2>

<p>Variabel stage bisa diset dengan berbagai cara. Bila kita menggunakan <a href="http://tomcat.apache.org">Apache Tomcat</a>, maka kita mengedit file startup.sh atau startup.bat. Modifikasi baris yang berisi CATALINA_OPTS menjadi seperti ini :</p>

<div><script src='https://gist.github.com/1134126.js?file=startup.sh'></script>
<noscript><pre><code>export CATALINA_OPTS=&quot;-Dstage=production&quot;</code></pre></noscript></div>


<p>Atau, kita bisa jalankan dengan Jetty melalui Maven</p>

<div><script src='https://gist.github.com/1134126.js?file=mvn-jetty-run.sh'></script>
<noscript><pre><code>mvn jetty:run -Dstage=testing</code></pre></noscript></div>


<p>Bisa juga melalui environment variabel sistem operasi, di Linux kita set seperti ini.</p>

<div><script src='https://gist.github.com/1134126.js?file=linux-env-var.sh'></script>
<noscript><pre><code>EXPORT stage=production</code></pre></noscript></div>


<h2>Konfigurasi Logger</h2>

<p>Dengan menggunakan Spring seperti di atas, kita bisa membaca konfigurasi apa saja, misalnya</p>

<ul>
<li><p>Konfigurasi email : bila aplikasi kita mengirim/menerima email</p></li>
<li><p>Konfigurasi server lain : bila aplikasi kita berinteraksi dengan aplikasi orang lain, misalnya webservice atau koneksi socket</p></li>
<li><p>dsb</p></li>
</ul>


<p>Walaupun demikian, konfigurasi logger biasanya tidak diload oleh Spring, melainkan langsung dibaca oleh library loggernya.</p>

<p>Kita di ArtiVisi menggunakan SLF4J dan Logback. Cara konfigurasinya mirip dengan Spring. Kita punya satu master file yang akan membaca file lain sesuai isi variabel stage. Untuk itu kita siapkan beberapa file berikut:</p>

<ul>
<li><p>logback.xml : file konfigurasi utama</p></li>
<li><p>logback.production.xml : konfigurasi logger production, akan diinclude oleh logback.xml</p></li>
<li><p>logback.testing.xml : konfigurasi logger testing, akan diinclude oleh logback.xml</p></li>
<li><p>logback.development.xml : konfigurasi logger development, akan diinclude oleh logback.xml</p></li>
</ul>


<p>Berikut isi file logback.xml.</p>

<div><script src='https://gist.github.com/1134126.js?file=logback.xml'></script>
<noscript><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;configuration&gt;

    &lt;appender name=&quot;STDOUT&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;
        &lt;encoder&gt;
            &lt;pattern&gt;%d %-5level %logger{35} - %msg %n&lt;/pattern&gt;
        &lt;/encoder&gt;
    &lt;/appender&gt;

    &lt;appender name=&quot;FILE&quot; class=&quot;ch.qos.logback.core.FileAppender&quot;&gt;
        &lt;file&gt;${catalina.home:-.}/logs/kasbon-${stage:-development}.log&lt;/file&gt;
        &lt;encoder&gt;
            &lt;pattern&gt;%d %-5level %logger{35} - %msg %n&lt;/pattern&gt;
        &lt;/encoder&gt;
    &lt;/appender&gt;

    &lt;include resource=&quot;logback-${stage:-development}.xml&quot;/&gt;

&lt;/configuration&gt;</code></pre></noscript></div>


<p>Seperti kita lihat, file ini berisi konfigurasi yang berlaku umum, seperti appender yang digunakan. Di file ini kita menulis variabel seperti ini</p>

<div><script src='https://gist.github.com/1134126.js?file=logback-variable.txt'></script>
<noscript><pre><code>${stage:-development}</code></pre></noscript></div>


<p>Yang artinya adalah, <a href="http://logback.qos.ch/manual/configuration.html">isi dengan variabel stage, kalau variabel tersebut tidak diset, defaultnya adalah development</a>. Ini sesuai dengan keinginan kita seperti pada waktu mengkonfigurasi Spring di atas.</p>

<p>Isi file logback-development.xml dan teman-temannya dapat dilihat <a href="https://github.com/artivisi/aplikasi-kasbon/tree/master/aplikasi-kasbon-config/src/main/resources">di Github</a>.</p>

<p>Demikianlah tutorial cara mengelola konfigurasi untuk keperluan staged deployment. Semoga bermanfaat.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <!-- Now we're back to normal posts. Note the links used under href in both headers.-->
        <h1 class="entry-title"><a href="/blog/Manajemen/meluruskan-mitos-cmmi/">Meluruskan Mitos CMMI</a></h1>
      
    
    
      <p class="meta">
        








  


<time datetime="2011-08-10T15:01:25+07:00" pubdate data-updated="true">Aug 10<span>th</span>, 2011</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Di milis manajemen proyek IT sedang rame diskusi tentang CMMI dan Scrum.
Seperti layaknya diskusi yang rame, perdebatan dibumbui dengan segala macam mitos dan &#8216;FUDification&#8217;.</p>

<p>Berikut adalah tanggapan saya tentang mitos yang berkembang mengenai CMMI, dicopy-paste dari posting milis dengan sedikit penyesuaian.</p>

<p>Beberapa mitos yang akan diluruskan :</p>

<ul>
<li><p>CMMI adalah metodologi manajemen proyek yang cenderung waterfall</p></li>
<li><p>CMMI mewajibkan kita bikin banyak dokumen</p></li>
</ul>


<p>Pada artikel ini, kita akan meluruskan mitos-mitos tersebut.</p>

<h2>CMMI = metodologi, cenderung waterfall</h2>

<p>CMMI bukanlah metodologi manajemen proyek seperti
<a href="http://en.wikipedia.org/wiki/Scrum_(development">Scrum</a>), <a href="http://en.wikipedia.org/wiki/IBM_Rational_Unified_Process">IBM Rational Unified Process</a>, <a href="http://en.wikipedia.org/wiki/Extreme_Programming">XP</a>, apalagi <a href="http://en.wikipedia.org/wiki/Waterfall_model">Waterfall</a>.</p>

<p>CMMI sebetulnya sudah pernah saya jelaskan <a href="http://endy.artivisi.com/blog/manajemen/apa-itu-cmmi/">di posting saya sebelumnya</a>.
Tapi untuk lebih menyederhanakan lagi, kita bisa analogikan CMMI seperti akreditasi perguruan tinggi.
Kalau kita mau daftar kuliah, biasanya kita cari tahu akreditasi kampus yang kita tuju.
Semakin tinggi akreditasinya, semakin tinggi ekspektasi kita terhadap kualitas perguruan tinggi tersebut.
<a href="http://ban-pt.kemdiknas.go.id/">Akreditasi perguruan tinggi</a> <a href="http://ban-pt.kemdiknas.go.id/index.php?option=com_content&amp;view=article&amp;id=57&amp;Itemid=63&amp;lang=in">ditentukan oleh banyak hal</a>, diantaranya :</p>

<ul>
<li><p>berapa jumlah dosen yang S3</p></li>
<li><p>berapa karya ilmiah dan penelitian yang dihasilkan dalam satu periode</p></li>
<li><p>dsb</p></li>
</ul>


<p>Untuk menentukan suatu kampus mendapat level A, B, atau lainnya, maka ada tim assessor yang akan memeriksa apakah kampus tersebut sudah memenuhi apa yang dipersyaratkan.</p>

<p>Demikian juga dengan CMMI, berisi seperangkat checklist yang bentuknya kira-kira seperti ini:</p>

<pre><code>        Level
        Process Area
        Ok
        Not Ok
</code></pre>

<p>2</p>

<p>Requirement Management</p>

<p>2</p>

<p>Configuration Management</p>

<p>2</p>

<p>Measurement and Analysis</p>

<p>2</p>

<p>Project Planning</p>

<p>2</p>

<p>Project Management and Control</p>

<p>2</p>

<p>PPQA</p>

<p>2</p>

<p>Supplier Agreement Management</p>

<p>Nah, checklist itu nanti akan dicentang sesuai dengan kapabilitas perusahaan yang diperiksa.</p>

<p>Adapun urusan Scrum, Waterfall, XP, whatever metodologi yang kita gunakan,
hanyalah mencakup sebagian saja dari CMMI.</p>

<p>CMMI itu model untuk menggambarkan organisasi pembuat software yang mature. Apa itu mature? Salah satu karakteristiknya adalah konsistensi. Perusahaan yang gak mature, hasil kerjanya gak konsisten. Project A ontime, Project B molor 3 tahun. Project X bugnya dikit, Project Y isinya bug doang gak ada fiturnya.</p>

<p>Kalau kita bisa mengeksekusi project dengan sukses, kita hanya bisa lulus CMMI level 2.
Untuk bisa mendapatkan level 3, kita harus bisa mengeksekusi project dengan sukses <strong>secara konsisten</strong>.
Untuk bisa konsisten, maka kita harus bisa menduplikasi project sukses ke seluruh perusahaan.
Jadi, kalau kita sudah sukses pakai Scrum di project kita sekarang, tetap saja baru level 2.
Hanya setelah kesuksesan Scrum bisa direplikasi di keseluruhan perusahaan, barulah bisa level 3.</p>

<p>Seperti juga halnya replikasi resep McDonalds ke seluruh cabang, untuk bisa mereplikasi project sukses ke seluruh perusahaan,
dibutuhkan kegiatan tambahan di level organisasi, misalnya :</p>

<ul>
<li><p>Menulis SOP (OPD)</p></li>
<li><p>Membuat program pelatihan internal (OT)</p></li>
<li><p>Selalu menganalisas prosedur yang sekarang berlaku, supaya bisa diimprove (OPF)</p></li>
</ul>


<p>Yang di dalam kurung adalah process area yang bersesuaian di CMMI.</p>

<p>Berurusan dengan perusahaan yang mature akan mengurangi resiko di client.
Apa itu resiko?
Buat orang awam seperti kita, resiko adalah simply sekian persen
kemungkinan adanya masalah di kemudian hari.
Nah, ada perspektif finansial yang kita orang teknis biasanya gak kepikiran.
Buat orang finance, persentase tersebut bisa diuangkan.
Misalnya kita mau bikin aplikasi costnya 100 M, uangnya minjem ke bank.
Karena pada dasarnya bank gak mau rugi, 100 M itu akan diasuransikan sama dia.
Jadi kalo projectnya bubaran, kita gak sanggup bayar, hutangnya akan
ditalangin sama asuransi.
Asuransi akan lihat, kita pakai vendor siapa.
Kalo vendornya gak mature (baca: resiko tinggi) maka premi asuransinya
akan tinggi.
Akibatnya, biaya pinjaman kita (cost of money) juga tinggi.
Bisa aja kita bayar 100 M (pokok) + 20 M (bunga) + 20 M (asuransi)
Padahal kalo vendornya mature, premi asuransinya cuma 5 M.</p>

<p>Nah, jadi urusan resiko dan maturity ini bukan semata jargon2 aja,
tapi ada duit beneran yang tersangkut di dalamnya.</p>

<p>Demikianlah mitos pertama, CMMI bukan metodologi manajemen proyek, melainkan manajemen keseluruhan perusahaan.</p>

<h2>CMMI mewajibkan kita bikin banyak dokumen</h2>

<p>CMMI sama sekali tidak mengharuskan kita bikin dokumen apa-apa.</p>

<p>Yang ada, kita harus :
- <strong>melakukan</strong> project planning (level 2)
- <strong>melakukan</strong> project monitoring &amp; control (level 2)
- <strong>mendefinisikan</strong> project life cycle : bisa waterfall, scrum, spiral,
cowboy programming juga boleh</p>

<p>Planning : merencanakan apa yang akan dilakukan
Monitoring : melihat kondisi aktual, apakah sesuai dengan plan
Control : melakukan tindakan kalau kondisi aktual tidak sesuai dengan plan</p>

<p>Nah, kita harus membuktikan bahwa kita benar2 melakukan apa yang disuruh.
Gimana cara membuktikannya?
Kita bisa :
1. Tunjukin dokumen hardcopy, atau
2. Tunjukin bahwa kita melakukan planning, monitoring, dan control di
aplikasi yang kita pake (Redmine, planningpoker.com,
pivotaltracker.com, basecamphq.com, fogbugz, whatever)</p>

<p>Nah, dari 2 cara di atas, kalo kita <strong>benar-benar</strong> melakukan, akan
lebih mudah menunjukkan yang #2.
Tapi kalo akal2an, sebenarnya gak planning tapi mau ngakunya planning,
akan lebih mudah memalsukan yang #1.
Soalnya #2 gak bisa di-back-dated, sedangkan #1 bisa.</p>

<p>Jadi, fokusnya lebih ke <strong>melakukan proses</strong>, bukan <strong>membuat dokumen</strong></p>

<p>Kemudian, ada kesalah-kaprahan juga yang umum terjadi tentang planning.
Planning itu tidak sekali saja lalu dipakai sepanjang project.
Project plan harus mencerminkan kondisi yang terbaru dari project.
Misalnya, kita bikin plan awal (versi 1) selesai 3 bulan.
Ternyata waktu monitoring di akhir bulan 1, kita udah tau bahwa gak
bakalan selesai dalam 2 bulan sisanya.
Kita harus melakukan controlling terhadap projectnya.
Tindakan control bisa macam2, bisa kita tambah orang biar tetap
selesai dalam 3 bulan,
bisa juga revisi plannya sehingga mencerminkan kondisi setelah 1 bulan berjalan.</p>

<p>UUD 45 aja bisa diamandemen, masa project plan gak bisa :D</p>

<p>Contoh lain, mengelola requirement (Requirement Management), Level 2.</p>

<p>S.P 1.1 : Understand Requirement : kita harus memastikan bahwa
requirement dipahami.
Gimana cara membuktikannya?
Kalo prosesnya beneran dijalanin, kita bisa tunjukkan email dari BA ke
Client yang isinya
mengkonfirmasi pemahaman BA tentang requirement yang diminta Client.
Atau kalo seperti Scrum, Clientnya hadir di ruangan yang sama, gak
nyatet apa2, rekaman audio juga boleh.
Intinya, ada sesuatu yang bisa ditunjukkan ke auditor bahwa kita sudah
Understanding Requirement.
Kalo prosesnya palsu, artinya sebenarnya gak dilakukan, tapi mau lulus
Level 2, maka dibuatlah dokumen palsu.
Bentuknya biasanya review report, isinya item2 requirement, lalu nanti
ada tandatangan client palsu.</p>

<p>So, overhead dokumen (mis: review report) itu ada kalo kita memalsukan proses.</p>

<p>Selama kita beneran menjalankan apa yang disuruh, pasti ada evidence
bahwa kita menjalankan,
entah itu bentuknya chat YM, email, Skype call, apalah terserah, tidak
ada CMMI mewajibkan formatnya harus mp3 atau apa.</p>

<p>SP 1.2 : Obtain Commitment to Requirement : semua pihak harus commit
terhadap requirement yang sudah dibuat.
Gimana cara membuktikan bahwa kita comply dengan SP ini?
Paling gampang, BA kirim email ke Client, &#8220;Pak, di iterasi ini, kita
kerjakan req #12, #14, sama #15 ya. #13 pending dulu aja&#8221;
Client reply, &#8220;Ok&#8221;
That&#8217;s it, tunjukin emailnya ke auditor, beres.
Kalo gak dijalanin, nanti ribet dikemudian hari, usernya client bilang
A, bosnya user bilang A+, programmer bilang C, PM bilang lain lagi.
Sekali lagi, selama prosesnya dilakukan, emailnya pasti ada.
Kalo prosesnya palsu, atau clientnya gaptek gak kenal email, ya
dibuatlah dokumen requirement sign off.
Orang2 tandatangan. Dokumennya dijadikan evidence.</p>

<p>SP 1.3 : Manage Requirement Changes : kalo requirement berubah, harus
di-manage.
Apa itu dimanage? Harus jelas :
- apa yang berubah
- siapa yang minta berubah
- siapa yang approve
- apa impactnya ke schedule/cost/effort/cuaca hari ini
Apa buktinya? Email boleh, chat log boleh, rekaman cctv boleh.</p>

<p>Ok, lalu kenapa semua harus ada evidence ??
Auditor kita di Sigma dulu becandanya gini,
In God We Trust, everybody else brings data.</p>

<p>Jadi, CMMI = banyak dokumen hanyalah mitos belaka. Untuk bisa melakukan verifikasi, auditor tentu butuh melihat evidence. Di jaman modern seperti sekarang, evidence bentuknya tidak harus dokumen tertulis yang dibuat dengan aplikasi office.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <!-- Now we're back to normal posts. Note the links used under href in both headers.-->
        <h1 class="entry-title"><a href="/blog/Aplikasi/Linux/redmine-jruby-tomca/">Instalasi Redmine Di Tomcat</a></h1>
      
    
    
      <p class="meta">
        








  


<time datetime="2011-08-07T04:06:01+07:00" pubdate data-updated="true">Aug 7<span>th</span>, 2011</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Ada berbagai cara instalasi Redmine, diantaranya:</p>

<ul>
<li><p>Dijalankan langsung dari command prompt dengan Webrick</p></li>
<li><p>Dijalankan menggunakan Mongrel dan FastCGI</p></li>
<li><p>Dijalankan menggunakan Ruby Enterprise Edition dan Passenger</p></li>
<li><p>Dibuat menjadi war dan dideploy ke application server Java seperti Tomcat, Glassfish, dsb</p></li>
</ul>


<p>Pada artikel ini, kita akan mencoba cara terakhir, yaitu menggunakan Tomcat untuk menghosting Redmine.
Ini saya lakukan supaya semua tools manajemen proyek ArtiVisi bisa disatukan di satu Tomcat, sehingga memudahkan kegiatan maintenance.
Sebelum Redmine, Tomcat ArtiVisi juga menghosting :</p>

<ul>
<li><p><a href="http://nexus.sonatype.org/">Nexus</a></p></li>
<li><p><a href="http://jenkins-ci.org/">Jenkins</a></p></li>
</ul>


<p>Dan nantinya, kalau sudah ada waktu dan kesempatan, juga akan menghosting <a href="http://code.google.com/p/gerrit/">Gerrit</a></p>

<p>Mari kita mulai.</p>

<h2>Instalasi JRuby</h2>

<p>Pertama, kita <a href="http://jruby.org/">Download JRuby</a>. Setelah itu, extract di folder yang diinginkan (contohnya /opt)</p>

<p>[gist id=1129237 file=install-jruby.sh]</p>

<p>Daftarkan jruby ke variabel PATH, supaya bisa diakses langsung dari command line.
Tulis baris berikut ini di dalam file ~/.bashrc</p>

<p>[gist id=1129237 file=bashrc]</p>

<p>Terakhir, test instalasi JRuby</p>

<p>[gist id=1129237 file=test-jruby.sh]</p>

<h2>Instalasi Paket Gem</h2>

<p>Redmine membutuhkan beberapa library Ruby yang dipaket dalam format gem, yaitu :</p>

<ul>
<li><p>rack versi 1.1.1 : ini adalah library untuk web server</p></li>
<li><p>rails versi 2.3.11 (dibutuhkan karena kita akan menginstal Redmine dari Subversion, bukan dari distribusi)</p></li>
<li><p>jruby-openssl : supaya bisa melayani https</p></li>
<li><p>activerecord-jdbcmysql-adapter : library untuk koneksi database</p></li>
<li><p>warbler : packager supaya Redmine bisa dibuat jadi war dan dideploy ke Tomcat</p></li>
</ul>


<p>Mari kita install</p>

<p>[gist id=1129237 file=install-gem.sh bump=1]</p>

<p>Semua paket sudah lengkap, mari kita lanjutkan ke</p>

<h2>Mengambil Redmine dari Subversion Repository</h2>

<p>Sebetulnya ada dua pilihan untuk mendapatkan Redmine, download versi rilis atau checkout langsung dari Subversion.
Saya lebih suka checkout langsung supaya nanti lebih gampang upgrade manakala rilis baru sudah terbit.</p>

<p>[gist id=1129237 file=checkout-redmine.sh]</p>

<p>Tunggu sejenak sampai proses checkout selesai. Setelah selesai, kita bisa langsung ke langkah selanjutnya.</p>

<h2>Konfigurasi Database</h2>

<p>Masuk ke folder Redmine, lalu copy file config/database.yml.example ke database.yml, kemudian edit.
Saya menggunakan konfigurasi development sebagai berikut :</p>

<p>[gist id=1129237 file=database.yml]</p>

<p>Tentunya kita harus sediakan database dengan konfigurasi tersebut di MySQL. Login ke MySQL, kemudian buatlah database dan usernya.</p>

<p>[gist id=1129237 file=create-database.sh]</p>

<p>Setelah databasenya selesai dibuat, selanjutnya kita akan melakukan inisialisasi.</p>

<h2>Inisialisasi Redmine</h2>

<p>Pertama, kita inisialisasi dulu session store. Ini digunakan untuk menyimpan cookie dan session variabel.</p>

<p>[gist id=1129237 file=inisialisasi-session.sh]</p>

<p>Setelah itu, inisialisasi skema database.</p>

<p>[gist id=1129237 file=inisialisasi-skema-db.sh]</p>

<p>Isi data awal.</p>

<p>[gist id=1129237 file=inisialisasi-data-awal.sh]</p>

<p>Setelah terisi, selanjutnya kita bisa test jalankan Redmine.</p>

<p>[gist id=1129237 file=start-webrick.sh]</p>

<p>Hasilnya bisa kita browse di http://localhost:3000
Kemudian kita bisa login dengan username admin dan password admin.</p>

<h2>Konfigurasi Email</h2>

<p>Issue tracker yang baik harus bisa mengirim email, supaya dia bisa memberikan notifikasi pada saat ada issue baru ataupun perubahan terhadap issue yang ada.
Redmine versi 1.2 membutuhkan file konfigurasi yang bernama configuration.yml, berada di folder config. Berikut isi file configuration.yml untuk mengirim email ke Gmail.</p>

<p>[gist id=1129237 file=configuration.yml]</p>

<p>Selain itu, kita juga harus menginstal plugin action_mailer_optional_tls, seperti dijelaskan <a href="http://redmineblog.com/articles/setup-redmine-to-send-email-using-gmail/">di sini</a>.</p>

<p>[gist id=1129237 file=install-action-mailer-tls.sh]</p>

<p>Coba restart Redmine, sesuaikan alamat email kita dengan cara klik link My Account di pojok kanan atas.
Di dalamnya ada informasi tentang email. Ganti dengan alamat email kita.
Kemudian pergi ke menu Administration > Settings > Email Notifications,
kemudian klik link Send a test email di pojok kanan bawah.
Tidak lama kemudian, seharusnya test email dari Redmine sudah masuk di mailbox kita.</p>

<p>Dengan demikian, Redmine sudah berhasil kita instal dan konfigurasi dengan baik.
Selanjutnya, kita akan paketkan supaya bisa dideploy di Tomcat.</p>

<h2>Generate WAR</h2>

<p>Pertama, kita harus inisialisasi dulu konfigurasi warble.</p>

<p>[gist id=1129237 file=warble-config.sh]</p>

<p>Dia akan menghasilkan file config/warble.rb. Mari kita edit sehingga menjadi seperti ini.</p>

<p>[gist id=1129237 file=warble.rb]</p>

<p>Selanjutnya, kita tinggal menjalankan perintah warble untuk menghasilkan file war.</p>

<p>[gist id=1129237 file=warble-generate.sh]</p>

<p>File war yang dihasilkan tinggal kita deploy ke Tomcat</p>

<p>[gist id=1129237 file=redmine-war-deploy.sh]</p>

<p>Jalankan Tomcat, dan Redmine bisa diakses di http://localhost:8080/redmine</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <!-- Now we're back to normal posts. Note the links used under href in both headers.-->
        <h1 class="entry-title"><a href="/blog/Aplikasi/Programming/instalasi-spket-ide/">Instalasi Spket IDE</a></h1>
      
    
    
      <p class="meta">
        








  


<time datetime="2011-07-07T02:16:13+07:00" pubdate data-updated="true">Jul 7<span>th</span>, 2011</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Beberapa minggu terakhir ini, saya mencari-cari cara terbaik untuk melakukan development dengan ExtJS.
Tentunya fitur utama yang kita inginkan adalah autocomplete,
sehingga tidak perlu bolak-balik membaca dokumentasi di websitenya.</p>

<p>Setelah berhari-hari mencari, akhirnya saya menemukan <a href="http://www.spket.com">Spket IDE</a>.
Di websitenya dinyatakan bahwa Spket sudah mendukung ExtJS versi 4, membuat saya tertarik untuk mencobanya.
Sayangnya, petunjuk instalasi sulit didapat, sehingga harus trial-and-error.</p>

<p>Di artikel ini, kita akan membahas petunjuk instalasi Spket IDE di Eclipse Indigo.</p>

<h2>Klik menu Install New Software</h2>

<p><a href="http://endy.artivisi.com/blog/wp-content/uploads/2011/07/01.-Install-New-Software.png"><img src="http://endy.artivisi.com/blog/wp-content/uploads/2011/07/01.-Install-New-Software.png" alt="" /></a></p>

<h2>Masukkan Update Site Spket IDE</h2>

<p>Tambahkan Update Site yang baru
<a href="http://endy.artivisi.com/blog/wp-content/uploads/2011/07/02.-Add-Update-Site.png"><img src="http://endy.artivisi.com/blog/wp-content/uploads/2011/07/02.-Add-Update-Site.png" alt="" /></a></p>

<p>Update sitenya adalah http://www.spket.com/update/</p>

<p><a href="http://endy.artivisi.com/blog/wp-content/uploads/2011/07/03.-Lokasi-Update-Site-Spket.png"><img src="http://endy.artivisi.com/blog/wp-content/uploads/2011/07/03.-Lokasi-Update-Site-Spket.png" alt="" /></a></p>

<h2>Opsi Instalasi Spket</h2>

<p><a href="http://endy.artivisi.com/blog/wp-content/uploads/2011/07/04.-Centang-Semua-Opsi.png"><img src="http://endy.artivisi.com/blog/wp-content/uploads/2011/07/04.-Centang-Semua-Opsi.png" alt="" /></a></p>

<h2>Klik Next</h2>

<p><a href="http://endy.artivisi.com/blog/wp-content/uploads/2011/07/05.-Next-Terus.png"><img src="http://endy.artivisi.com/blog/wp-content/uploads/2011/07/05.-Next-Terus.png" alt="" /></a></p>

<p><a href="http://endy.artivisi.com/blog/wp-content/uploads/2011/07/06.-Sit-Back-and-Relax.png"><img src="http://endy.artivisi.com/blog/wp-content/uploads/2011/07/06.-Sit-Back-and-Relax.png" alt="" /></a></p>

<p><a href="http://endy.artivisi.com/blog/wp-content/uploads/2011/07/07.-Ada-Warning-Lanjut-Saja.png"><img src="http://endy.artivisi.com/blog/wp-content/uploads/2011/07/07.-Ada-Warning-Lanjut-Saja.png" alt="" /></a></p>

<p>Ada warning, klik saja Yes.</p>

<h2>Download Support ExtJS 4</h2>

<p>Agar bisa mengenali ExtJS 4, kita harus <a href="http://forums.spket.com/viewtopic.php?f=6&amp;t=1866">mengunduh update terbaru dari forumnya</a>.
Entah apa alasannya, tiap ada update baru, versi jarnya tidak dinaikkan dan update sitenya tidak diperbarui.
Ini menyebabkan kita harus mengunduh file dari forum.</p>

<p>Ada dua file yang harus diunduh, yaitu jar
<a href="http://endy.artivisi.com/blog/wp-content/uploads/2011/07/08.-Download-jar-terbaru.png"><img src="http://endy.artivisi.com/blog/wp-content/uploads/2011/07/08.-Download-jar-terbaru.png" alt="" /></a></p>

<p>dan jsb
<a href="http://endy.artivisi.com/blog/wp-content/uploads/2011/07/09.-Dukungan-Ext-4.png"><img src="http://endy.artivisi.com/blog/wp-content/uploads/2011/07/09.-Dukungan-Ext-4.png" alt="" /></a>
Hasilnya, kita akan memiliki dua file.
<a href="http://endy.artivisi.com/blog/wp-content/uploads/2011/07/13.-Hasil-donlod-dari-forum-spket.png"><img src="http://endy.artivisi.com/blog/wp-content/uploads/2011/07/13.-Hasil-donlod-dari-forum-spket.png" alt="" /></a></p>

<h2>Patch Eclipse</h2>

<p>File jar akan kita pasang di folder plugins di tempat Eclipse terinstal.<br/>
<a href="http://endy.artivisi.com/blog/wp-content/uploads/2011/07/11.-Folder-Plugin-Eclipse.png"><img src="http://endy.artivisi.com/blog/wp-content/uploads/2011/07/11.-Folder-Plugin-Eclipse.png" alt="" /></a></p>

<p>Ini akan menimpa file dengan nama sama.
<a href="http://endy.artivisi.com/blog/wp-content/uploads/2011/07/14.-Replace-dengan-yang-baru.png"><img src="http://endy.artivisi.com/blog/wp-content/uploads/2011/07/14.-Replace-dengan-yang-baru.png" alt="" /></a></p>

<h2>Patch ExtJS</h2>

<p>Sedangkan file jsb akan kita pasang di folder ExtJS 4.
<a href="http://endy.artivisi.com/blog/wp-content/uploads/2011/07/15.-Masukkan-jsb-ke-folder-extjs.png"><img src="http://endy.artivisi.com/blog/wp-content/uploads/2011/07/15.-Masukkan-jsb-ke-folder-extjs.png" alt="" /></a></p>

<h2>Edit jsb</h2>

<p>Sayangnya, file jsb ini juga masih ada bugnya. Dia salah menyebutkan nama file dalam folder pkgs.
Kita harus edit, ganti <code>all.js</code> menjadi <code>classes.js</code>.
<a href="http://endy.artivisi.com/blog/wp-content/uploads/2011/07/16.-Edit-file-jsb-sesuai-nama-file.png"><img src="http://endy.artivisi.com/blog/wp-content/uploads/2011/07/16.-Edit-file-jsb-sesuai-nama-file.png" alt="" /></a></p>

<h2>Konfigurasi Spket</h2>

<p>Selanjutnya, kita masuk ke menu preferences untuk melakukan konfigurasi.
<a href="http://endy.artivisi.com/blog/wp-content/uploads/2011/07/17.-Konfigurasi-Spket.png"><img src="http://endy.artivisi.com/blog/wp-content/uploads/2011/07/17.-Konfigurasi-Spket.png" alt="" /></a>
Masuk ke menu Spket - Javascript Profile
<a href="http://endy.artivisi.com/blog/wp-content/uploads/2011/07/18.-Javascript-Profile.png"><img src="http://endy.artivisi.com/blog/wp-content/uploads/2011/07/18.-Javascript-Profile.png" alt="" /></a>
Tambah Profile baru, beri nama ExtJS
<a href="http://endy.artivisi.com/blog/wp-content/uploads/2011/07/19.-Tambah-profile-baru.png"><img src="http://endy.artivisi.com/blog/wp-content/uploads/2011/07/19.-Tambah-profile-baru.png" alt="" /></a>
Di profile yang baru saja ditambahkan, Add Library dan pilih ExtJS
<a href="http://endy.artivisi.com/blog/wp-content/uploads/2011/07/20.-Tambah-library-ExtJS.png"><img src="http://endy.artivisi.com/blog/wp-content/uploads/2011/07/20.-Tambah-library-ExtJS.png" alt="" /></a>
Setelah itu, Add File jsb yang sudah kita edit tadi.
<a href="http://endy.artivisi.com/blog/wp-content/uploads/2011/07/21.-Add-File-JSB.png"><img src="http://endy.artivisi.com/blog/wp-content/uploads/2011/07/21.-Add-File-JSB.png" alt="" /></a>
Lalu, set profile ExtJS menjadi default
<a href="http://endy.artivisi.com/blog/wp-content/uploads/2011/07/22.-Set-Profile-ExtJS-sebagai-default.png"><img src="http://endy.artivisi.com/blog/wp-content/uploads/2011/07/22.-Set-Profile-ExtJS-sebagai-default.png" alt="" /></a>
Kemudian, pergi ke menu General - Editors - File Associations. Pilih file js, dan jadikan Spket sebagai editornya.
<a href="http://endy.artivisi.com/blog/wp-content/uploads/2011/07/23.-Set-file-associations.png"><img src="http://endy.artivisi.com/blog/wp-content/uploads/2011/07/23.-Set-file-associations.png" alt="" /></a>
Klik Ok, restart Eclipse.
<a href="http://endy.artivisi.com/blog/wp-content/uploads/2011/07/10.-Restart-Eclipse.png"><img src="http://endy.artivisi.com/blog/wp-content/uploads/2011/07/10.-Restart-Eclipse.png" alt="" /></a></p>

<h2>Code Completion</h2>

<p>Sekarang kita bisa melakukan code completion pada saat memberi titik di depan object.
<a href="http://endy.artivisi.com/blog/wp-content/uploads/2011/07/24.-Autocomplete-method.png"><img src="http://endy.artivisi.com/blog/wp-content/uploads/2011/07/24.-Autocomplete-method.png" alt="" /></a>
Atau juga pada saat mengetik di dalam tanda kurung.
<a href="http://endy.artivisi.com/blog/wp-content/uploads/2011/07/25.-Autocomplete-property.png"><img src="http://endy.artivisi.com/blog/wp-content/uploads/2011/07/25.-Autocomplete-property.png" alt="" /></a></p>

<p>Demikianlah cara instalasi Spket IDE di Eclipse.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <!-- Now we're back to normal posts. Note the links used under href in both headers.-->
        <h1 class="entry-title"><a href="/blog/Aplikasi/Linux/membuat-screencast/">Membuat Screencast</a></h1>
      
    
    
      <p class="meta">
        








  


<time datetime="2011-06-28T01:03:23+07:00" pubdate data-updated="true">Jun 28<span>th</span>, 2011</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Jaman sekarang sudah semakin maju. Fakir bandwidth semakin sedikit. Oleh karena itu, media komunikasi juga berubah, yang tadinya berbasis teks (hemat bandwidth) menjadi multimedia (rakus bandwidth).</p>

<p>Demi mengikuti perkembangan jaman, saya mengeksplorasi pembuatan tutorial dalam bentuk screencast. Ternyata hasilnya memuaskan. Dengan beberapa menit merekam screencast, informasi yang disampaikan sama dengan beberapa jam mengetik blog entry.</p>

<p>Artikel ini saya tulis untuk mendokumentasikan langkah-langkah membuat screencast, mulai dari merekam screencast, sampai mempublikasikannya di blog.</p>

<h2>Merekam video</h2>

<p>Di Ubuntu ada dua aplikasi yang saya coba, yaitu Xvidcap dan Record My Desktop. Dua-duanya sama fungsinya dan tidak ada perbedaan yang signifikan. Setelah mencoba keduanya, pendapat saya adalah Record My Desktop lebih mudah digunakan. Jadi, inilah aplikasi yang saya pilih.</p>

<p>Perlu diperhatikan kemampuan prosesor komputer Anda. Ini kaitannya dengan setting frame per second (fps). Bila fps melebihi kemampuan prosesor, video yang kita rekam akan terlihat lebih cepat dari sebenarnya. Di laptop saya, setting 15 fps akan menghasilkan video yang kira-kira 2x lebih cepat. Setelah trial and error, saya temukan bahwa 9 fps adalah setting yang tepat.</p>

<p>Perbedaan yang utama di antara kedua aplikasi ini adalah format outputnya. Record My Desktop mengeluarkan format ogv sedangkan Xvidcap mengeluarkan format mpeg. Perbedaan format ini nantinya akan mempengaruhi langkah pemrosesan selanjutnya.</p>

<h2>Merekam suara</h2>

<p>Biasanya, saya merekam suara dalam proses yang terpisah, supaya tidak banyak ehm dan eee. Rekaman dibuat sambil menonton screencast yang sudah kita rekam. Setelah rekaman suara dibuat, bisa diedit dengan menggunakan aplikasi Audacity untuk menghilangkan noise, memotong bagian yang tidak penting, dan sebagainya.</p>

<h2>Menggabungkan video dan audio</h2>

<p>Selanjutnya, kita menggunakan aplikasi Avidemux untuk menggabungkan file audio dan file video menjadi satu file. Dengan aplikasi ini kita juga bisa mengedit video untuk menghilangkan bagian-bagian yang tidak perlu ataupun menyambung beberapa video menjadi satu.</p>

<h2>Mempersiapkan format video untuk web</h2>

<p>Ada berbagai format video yang tersedia. Masing-masing format memiliki dukungan browser yang berbeda-beda. Daftar lengkapnya bisa dilihat <a href="http://diveintohtml5.info/video.html#what-works">di sini</a></p>

<p>Pada intinya, supaya bisa dilihat di berbagai browser, kita harus menyediakan file dengan format ogv, mp4, dan webm. Kita juga harus menyertakan poster dalam format jpg atau png supaya bisa ditampilkan dengan benar di browser.</p>

<p>Ada beberapa script yang bisa digunakan, misalnya <a href="https://github.com/kwiliarty/vfe-sh">ini</a> atau <a href="http://brettterpstra.com/automating-html5-video-encodes/">ini</a></p>

<p>Atau, kita juga bisa menjalankan commandnya satu persatu di command line. Berikut adalah command yang saya jalankan :</p>

<p>Konversi dari ogv menjadi mp4
[gist id=1048657 file=ogv-to-mp4.sh]</p>

<p>Konversi dari ogv menjadi webm
[gist id=1048657 file=ogv-to-webm.sh]</p>

<p>Command di atas mungkin berbeda bila file asli kita formatnya adalah mpeg seperti yang dihasilkan oleh XVidcap.</p>

<p>Membuat poster
[gist id=1048657 file=create-poster.sh]</p>

<h2>Upload</h2>

<p>Setelah semua file(ogv,mp4,png) terkumpul di satu folder, kita upload menggunakan rsync
[gist id=1048657 file=upload-to-server.sh]</p>

<h2>Tampilkan di blog</h2>

<p>Terakhir, kita ingin menayangkan video tersebut di blog kita. Karena saya menggunakan wordpress, saya pasang <a href="http://open.pages.kevinwiliarty.com/external-video-for-everybody/">plugin External Video for Everybody</a>. Plugin ini menampilkan video player di browser kita, supaya orang lain bisa langsung klik tombol play. Di belakang layar, plugin ini mendeteksi apakah browser kita mendukung HTML 5 atau tidak. Kalau iya, maka video akan ditampilkan dengan tag khusus <video>. Bila tidak, maka flash player akan digunakan. Flash player ini tidak disediakan oleh plugin ini. Kita perlu memilih dan mendownload sendiri dari sekian banyak flash player yang tersedia, contohnya <a href="http://www.longtailvideo.com/players/jw-flv-player/">JW Player</a></p>

<p>Sebagai penutup, bisa melihat <a href="http://linuxandfriends.com/2009/07/13/how-to-create-a-screencast-in-ubuntu-linux/">tutorial ini</a> yang saya gunakan sebagai titik awal eksplorasi saya.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <!-- Now we're back to normal posts. Note the links used under href in both headers.-->
        <h1 class="entry-title"><a href="/blog/Java/PHP/tutorial-extjs/">Tutorial ExtJS</a></h1>
      
    
    
      <p class="meta">
        








  


<time datetime="2011-06-21T20:15:31+07:00" pubdate data-updated="true">Jun 21<span>st</span>, 2011</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Hari Senin kemarin, ArtiVisi mengadakan internal training mengenai ExtJS yang diikuti oleh programmer ArtiVisi dan sister company. Berikut adalah materi trainingnya.</p>

<h2>Cara setup project ExtJS</h2>

<p>[external-vfe name=&#8221;01. Setup ExtJS&#8221; path=&#8221;http://artivisi.com/~endy/videos/training-extjs/&#8221;]</p>

<h2>Memahami Layout</h2>

<p>[external-vfe name=&#8221;02. ExtJS Layout&#8221; path=&#8221;http://artivisi.com/~endy/videos/training-extjs/&#8221;]</p>

<h2>Membuat Menubar</h2>

<p>[external-vfe name=&#8221;03. Klik Menu muncul Tab&#8221; path=&#8221;http://artivisi.com/~endy/videos/training-extjs/&#8221;]</p>

<h2>Membuat User Management Screen</h2>

<p>[external-vfe name=&#8221;04. Membuat User Management Screen&#8221; path=&#8221;http://artivisi.com/~endy/videos/training-extjs/&#8221;]</p>

<h2>Membuat Toolbar CRUD</h2>

<p>[external-vfe name=&#8221;05. Membuat Toolbar CRUD&#8221; path=&#8221;http://artivisi.com/~endy/videos/training-extjs/&#8221;]</p>

<p>Masih ada beberapa materi lanjutan yang belum sempat disampaikan, yaitu:</p>

<ul>
<li><p>Enable/Disable Form</p></li>
<li><p>Save isi form ke server</p></li>
<li><p>Query data dari server, tampilkan ke grid</p></li>
</ul>


<p>Kode program yang digunakan pada training ini dapat diikuti di <a href="https://github.com/endymuhardin/belajar-extjs">Github page saya</a></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <!-- Now we're back to normal posts. Note the links used under href in both headers.-->
        <h1 class="entry-title"><a href="/blog/Manajemen/estimasi-proyek-software/">Estimasi Proyek Software</a></h1>
      
    
    
      <p class="meta">
        








  


<time datetime="2011-05-11T06:37:12+07:00" pubdate data-updated="true">May 11<span>th</span>, 2011</time>
        
      </p>
    
  </header>


  <div class="entry-content"><blockquote><p>Saya ingin membuat aplikasi akunting, berapa lama dan berapa biayanya?</p></blockquote>

<p>Demikian pertanyaan yang amat sering kita temui di profesi software developer.</p>

<p>Topik estimasi proyek merupakan topik yang sulit. Steve McConnell menyebutnya Black Art,
sehingga dia mengarang buku yang sangat bagus tentang topik ini,
judulnya Software Estimation, Demystifying the Black Art.</p>

<p>Menurut Steve, dalam membuat estimasi, ada 3 metode yang dilakukan, yaitu</p>

<ul>
<li><p>count</p></li>
<li><p>compute</p></li>
<li><p>judge</p></li>
</ul>


<p>Kita harus selalu berusaha count, karena ini yang paling akurat.
Kalo ditanya berapa tinggi pohon, paling baik adalah ambil meteran dan ukur pohonnya.
Dimana kita tidak bisa count, maka kita compute.
Contohnya, di sebelah pohon ada pagar dan di atas pagar ada tiang lampu.
Kita compute jumlah tinggi pagar dan tinggi tiang lampu, sehingga dapat tinggi pohon.
Hanya kalau tidak ada cara lain, baru kita judge.
Dikira2 tingginya berapa.</p>

<p>Dalam kaitannya dalam estimasi, idealnya yang kita estimasi hanyalah project size.
Metric lainnya akan kita compute dari project size ini.</p>

<h2>Apa itu project size?</h2>

<p>Project size merupakan ukuran suatu project.
Dengan project size, kita bisa membandingkan dua aplikasi yang berbeda,
misalnya aplikasi akunting dan aplikasi toko online.</p>

<p>Ada banyak metric untuk mengukur ukuran project. Metric yang paling lazim digunakan
adalah jumlah baris kode program, dalam bahasa Inggris disebut Source Lines of Code (SLOC)
atau Non Commenting Source Code (NCSS).</p>

<p>Walaupun SLOC sangat akurat dalam menentukan ukuran project, tapi jumlah baris kode sulit diperkirakan di awal project.
Oleh karena itu, beberapa orang kreatif lalu mengarang metode baru yang disebut Function Point Calculation.
Metode ini pada intinya adalah menghitung berapa screen input, screen output, jumlah tabel database, dan interaksinya dengan aplikasi lain.</p>

<p>Setelah kita mendapatkan estimasi ukuran project, kita akan menggunakannya untuk mengestimasi effort, durasi, dan cost.</p>

<p>Sebelum lebih jauh, mari kita jelaskan istilah-istilahnya.</p>

<p>Effort, adalah kerja real yang kita lakukan dalam menyelesaikan project. Satuannya adalah mandays atau manhour.
Misalnya suatu aplikasi diestimasi membutuhkan effort 10 mandays. Artinya aplikasi ini akan selesai bila dikerjakan 1 orang selama 10 hari terus menerus.
Atau 5 hari bila ada 2 pekerja. Effort tidak mempertimbangkan libur ataupun cuti.</p>

<p>Durasi (bahasa Inggrisnya schedule), adalah jangka waktu penyelesaian project. Ini biasanya dinyatakan dalam satuan hari kerja atau hari kalender.
Bila durasi project dinyatakan 10 hari kalender, maka bila dimulai tanggal 1, akan selesai tanggal 10.</p>

<p>Jadi, untuk mendapatkan durasi, kita harus punya asumsi berikut :</p>

<ul>
<li><p>berapa orang yang dipekerjakan</p></li>
<li><p>berapa hari libur</p></li>
<li><p>berapa alokasi waktu non-pekerjaan seperti meeting, presentasi, dsb</p></li>
</ul>


<p>Asumsi tersebut, digabungkan dengan estimasi effort, akan menghasilkan estimasi durasi.</p>

<p>Setelah durasi didapatkan, menghitung estimasi cost mudah saja. Kita membutuhkan matriks gaji per role.
Berapa gaji project manager, gaji programmer, dan role lain dalam setahun, termasuk THR, tunjangan kesehatan, benefit lain dan bonus.
Bagilah dengan hari kerja setahun sehingga didapatkan nilai gaji sehari.
Kemudian petakan penggunaan masing-masing role dalam schedule yang sudah kita estimasi, dan kita akan mendapat biaya personel.
Tambahkan dengan biaya lain-lain seperti transport, komunikasi, dsb untuk mendapatkan biaya total.
Masukkan juga faktor resiko project, misalnya kalau clientnya terkenal sulit ditagih, tentu perlu ada koefisien pengali.
Karena tagihan macet sama dengan kita memberi hutang ke client.</p>

<p>Nah, akhirnya biaya total sudah didapatkan, silahkan tambahkan profit yang diinginkan, buffer negosiasi, dan voila, dapatlah harga penawaran.</p>

<p>Selesai? Belum dong :D</p>

<p>Pembaca yang teliti tentu akan menemukan satu celah di penjelasan di atas. Bagaimana mengkonversi estimasi project size menjadi estimasi effort?
Nah disinilah bedanya perusahaan besar kaya pengalaman dengan startup mahasiswa baru lulus. Perusahaan dengan jam terbang tinggi biasanya punya data historis.
Dia punya data misalnya berapa mandays yang dibutuhkan programmer untuk membuat aplikasi dengan 3 tabel database.
Tentunya data ini harus dikumpulkan, diolah, dan diupdate agar bisa dijadikan pedoman. Ini sebabnya tidak semua perusahaan besar punya data ini.
Dengan bermodalkan data ini, perusahaan tinggal mengkonversi project size menjadi effort.
Setidaknya ada dua jenis data yang kita butuhkan, yaitu berapa effort yang dibutuhkan untuk menyelesaikan satu baris kode, dan bagaimana distribusi effort selama fase project. Maksudnya, bila project kita diestimasi 100 mandays, berapa mandays habis di analisa, coding, testing, implementasi, dan maintenance.
Selain itu, juga perlu ada matriks distribusi effort per role. Dengan adanya matriks ini, kita akan lebih mudah menkonversi effort menjadi durasi dan cost.</p>

<p>Startup mahasiswa, karena tidak punya data, maka cuma bisa tebak-tebak buah manggis. Atau kalo mau sedikit ilmiah, bisa mengikuti cara kami di ArtiVisi waktu baru mulai dulu. Kita membuat aplikasi kecil, kemudian datanya dikumpulkan dan dijadikan pedoman.</p>

<p>Jadi, kesimpulannya, begini metode estimasinya.</p>

<p><strong>Kebutuhan Data</strong></p>

<ol>
<li><p>Tabel konversi size ke mandays</p></li>
<li><p>Tabel gaji pegawai per role per hari</p></li>
<li><p>Tabel distribusi effort per fase</p></li>
<li><p>Tabel distribusi effort per role</p></li>
</ol>


<p>Flow Estimasi</p>

<ol>
<li><p>Estimasi Size</p></li>
<li><p>Dari size, gunakan tabel #1 untuk mendapatkan effort</p></li>
<li><p>Dari effort, gunakan tabel #3 untuk mendapatkan durasi</p></li>
<li><p>Dari effort, gunakan tabel #4 untuk mendapatkan effort per personel</p></li>
<li><p>Dari effort per personel, gunakan tabel #2 untuk menghitung biaya personel</p></li>
<li><p>Gunakan durasi untuk menghitung biaya lain-lain</p></li>
</ol>


<p>Demikian metodologi untuk melakukan estimasi project software. Membuat estimasi saja tidak cukup, kita juga harus bisa mempresentasikan dan mempertahankannya dari negosiasi pihak lain. Ini akan dibahas di lain kesempatan.</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/blog/page/2/">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/Java/konsep-dasar-log4/">Konsep Dasar Log4j</a>
      </li>
    
      <li class="post">
        <a href="/blog/Java/monitoring-aplikasi-java/">Monitoring Aplikasi Java</a>
      </li>
    
      <li class="post">
        <a href="/blog/Linux/backup-home-folder/">Backup Home Folder</a>
      </li>
    
      <li class="post">
        <a href="/blog/Java/Manajemen/staged-deployment/">Staged Deployment</a>
      </li>
    
      <li class="post">
        <a href="/blog/Manajemen/meluruskan-mitos-cmmi/">Meluruskan Mitos CMMI</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating&#8230;</li>
  </ul>
  
  <a href="https://github.com/endymuhardin">@endymuhardin</a> on GitHub
  
  <script type="text/javascript">
    $.domReady(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'endymuhardin',
            count: 0,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>


<section>
  <h1>Latest Tweets</h1>
  <ul id="tweets">
    <li class="loading">Status updating&#8230;</li>
  </ul>
  <script type="text/javascript">
    $.domReady(function(){
      getTwitterFeed("endymuhardin", 4, false);
    });
  </script>
  <script src="/javascripts/twitter.js" type="text/javascript"> </script>
  
    <a href="http://twitter.com/endymuhardin" class="twitter-follow-button" data-show-count="false">Follow @endymuhardin</a>
  
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2012 - Endy Muhardin -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = 'http://platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
