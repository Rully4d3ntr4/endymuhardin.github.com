
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Akses Database dengan Spring 2.5 - Living life and make it better</title>
  <meta name="author" content="Endy Muhardin">

  
  <meta name="description" content="Akses database dengan Spring 2.5 Spring 2.5 baru saja keluar. Rilis kali ini membawa penambahan fitur yang cukup signifikan di sisi konfigurasi. &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://endy.artivisi.com/blog/java/akses-database-spring25/">
  <link href="/favicon.ico" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="/javascripts/ender.js"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <link href="/atom.xml" rel="alternate" title="Living life and make it better" type="application/atom+xml">
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href='http://fonts.googleapis.com/css?family=Lato:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
<link href='http://fonts.googleapis.com/css?family=Inconsolata' rel='stylesheet' type='text/css'>

<meta property="fb:app_id" content="269506799827290" />



  <link href="/stylesheets/data-table.css" media="screen, projection" rel="stylesheet" type="text/css" />
  

  

</head>

<body   >
  <header role="banner"><hgroup>
  <div id="logo">
  	<div id="logoLeft">{</div>
  	<div id="logoText">endymuhardin</div>
  	<div id="logoRight">}</div>
  	<div class="clear"></div>
  </div>
  <h1><a href="/">Living life and make it better</a></h1>
  
    <h2>life, learn, contribute</h2>
  
  <div class="clear"></div>
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:endy.artivisi.com/blog" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/archives">Archives</a></li>
  <li><a href="/about">About</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      
        <h1 class="entry-title">Akses Database Dengan Spring 2.5</h1>
      
    
    
      <p class="meta">
        








  


<time datetime="2007-12-03T21:12:07+07:00" pubdate data-updated="true">Dec 3<span>rd</span>, 2007</time>
        
      </p>
    
  </header>


<div class="entry-content"><p>Akses database dengan Spring 2.5</p>

<p>Spring 2.5 baru saja keluar. Rilis kali ini membawa penambahan fitur yang cukup signifikan di sisi konfigurasi. Dalam Spring yang baru ini, kita bisa mengkonfigurasi aplikasi melalui annotation. Suatu hal yang sangat bermanfaat untuk mengurangi jumlah baris kode XML kita.</p>

<p>Sebetulnya tidak ada yang salah dengan XML. Walaupun demikian, ada beberapa hal yang menurut saya kurang tepat kalau dikonfigurasi melalui XML, diantaranya:</p>

<ul>
<li>konfigurasi transaction</li>
<li>deklarasi bean standar</li>
</ul>


<p>Konfigurasi transaction biasanya tergantung dari kode program yang ingin ber-transaction. Bila kita konfigurasi di XML, maka untuk memikirkan satu logika akses database, kita harus melihat di dua tempat yang berbeda; file java dan file XML. Menurut pendapat saya, fitur declarative transaction walaupun kelihatannya mirip konfigurasi, tapi pada dasarnya adalah logika aplikasi. Tempatnya bukan di konfigurasi XML, tapi di kode Java.</p>

<p>Di Spring, kita harus mendaftarkan object aplikasi kita ke dalam object ApplicationContext agar bisa dikelola oleh Spring. Pada rilis sebelumnya, pendaftaran ini dilakukan dalam file XML. Cara ini memiliki incremental cost yang tinggi. Bila kita punya 100 object yang ingin dikelola, maka kita harus punya 100 deklarasi di konfigurasi XML Spring. Sekarang kita bisa menandai object yang akan dikelola Spring melalui annotation. Jadi walaupun ada 100 object, konfigurasi XML kita tidak bertambah.</p>

<p>Ok, cukup berteori. Saatnya melihat contoh kode.</p>

<p>Pada artikel kali ini, kita akan membuat kode akses database untuk class Person. Class ini tidak istimewa, cuma POJO biasa dengan tiga property: id, name, dan email. Berikut kodenya.</p>

<h3>Person.java</h3>

<pre><code>package tutorial.spring25.model;
public class Person {
  private Long id;
  private String name;
  private String email;
}
</code></pre>

<p>Jangan lupa membuat getter dan setter.</p>

<p>Class ini akan kita simpan di database dalam tabel bernama T_PERSON. Berikut definisinya untuk database MySQL.</p>

<h3>MySQL-schema.sql</h3>

<pre><code>create table T_PERSON (
  id BIGINT PRIMARY KEY AUTO_INCREMENT, 
  name VARCHAR(255), 
  email VARCHAR(255)
);
</code></pre>

<p>Operasi database yang akan kita buat dijelaskan oleh interface PersonDao, sebagai berikut.</p>

<h3>PersonDao.java</h3>

<pre><code>package tutorial.spring25.dao
public interface PersonDao {
  public List&lt;person&gt; getAll();
  public Person getById(Long id);
  public void save(Person p);
}
</code></pre>

<p>Untuk tahap pertama, kita akan lihat cara mengakses database dengan JDBC helper yang disediakan Spring. Akses database dengan Hibernate akan dijelaskan pada artikel terpisah.</p>

<p>Berikut adalah kerangka implementasi PersonDao dengan JDBC helper dari Spring.</p>

<h3>PersonDaoSpringJdbc.java</h3>

<pre><code>package tutorial.spring25.dao.springjdbc;

@Repository("personDao")
@Transactional(readOnly=true)
public class PersonDaoSpringJdbc implements PersonDao { 
    @Autowired
    public void setDataSource(final DataSource dataSource) {

    }

    @Override
    public List&lt;person&gt; getAll() {
        return null;
    }

    @Override
    public Person getById(final Long id) {
        return null;
    }

    @Override
    @Transactional(readOnly=false)
    public void save(final Person person) {

    }
}
</code></pre>

<p>Ada beberapa hal yang baru pada kode di atas. Kita melihat ada annotation @Repository, @Transactional, dan @Autowired.</p>

<p>Annotation @Repository memberi tahu pada Spring bahwa class ini adalah salah satu @Component dalam aplikasi kita. Semua @Component akan dipindai pada waktu inisialisasi dan kemudian diregistrasi ke dalam object ApplicationContext milik Spring. Selain @Repository, @Component juga memiliki turunan @Service dan @Controller. @Service biasanya digunakan untuk menandai class-class facade atau business delegate. Sedangkan @Controller digunakan untuk aplikasi web. @Service dan @Controller akan kita bahas di artikel terpisah.</p>

<p>Annotation @Transactional menandakan bahwa semua method dalam class ini akan dijalankan dalam transaksi database. Kita memberikan nilai readOnly=true pada deklarasi class, menandakan bahwa secara default transaksi hanya digunakan untuk mengambil data dari database. Perhatikan method save. Pada method ini, kita akan memasukkan atau mengubah data dalam database. Untuk satu method ini, kita membutuhkan transaksi yang tidak readOnly. Karena itu, kita override konfigurasi default dengan cara memberikan annotation @Transactional(readOnly=false).</p>

<p>Sekarang mari kita lihat konfigurasi Application Context.</p>

<h3>applicationContext.xml</h3>

<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:p="http://www.springframework.org/schema/p"
    xmlns:aop="http://www.springframework.org/schema/aop"
    xmlns:context="http://www.springframework.org/schema/context"
    xmlns:jee="http://www.springframework.org/schema/jee"
    xmlns:tx="http://www.springframework.org/schema/tx"
    xsi:schemaLocation="
        http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.5.xsd
    http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
    http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd
    http://www.springframework.org/schema/jee http://www.springframework.org/schema/jee/spring-jee-2.5.xsd
    http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.5.xsd"&gt;

    &lt;context:property-placeholder location="classpath:jdbc.properties"/&gt;
    &lt;context:annotation-config/&gt;
    &lt;context:component-scan base-package="tutorial.spring25"/&gt; &lt;!-- tidak perlu deklarasi masing2 DAO --&gt;
    &lt;tx:annotation-driven /&gt; &lt;!-- tidak perlu deklarasi transaction setting per method --&gt;

    &lt;bean id="dataSource"
        class="org.springframework.jdbc.datasource.DriverManagerDataSource"
        destroy-method="close" 
        p:driverClassName="${jdbc.driver}"
        p:url="${jdbc.url}" 
        p:username="${jdbc.username}"
        p:password="${jdbc.password}" /&gt;

    &lt;bean id="transactionManager"
        class="org.springframework.jdbc.datasource.DataSourceTransactionManager"
        p:dataSource-ref="dataSource" /&gt;

&lt;/beans&gt;
</code></pre>

<p>Seperti kita lihat di atas, kita tidak lagi membutuhkan deklarasi untuk object personDao seperti pada Spring sebelumnya. Kita juga tidak perlu membuat konfigurasi transaksi untuk masing-masing method dalam PersonDao. Sebagai gambaran, kita menghilangkan beberapa baris yang seperti ini.</p>

<h3>Konfigurasi DAO dan Transaksi</h3>

<pre><code>&lt;bean id="personDaoImpl" class="tutorial.spring25.dao.springjdbc.PersonDaoSpringJdbc"&gt;
    &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="personDao" class="org.springframework.transaction.interceptor.TransactionProxyFactoryBean"&gt;
    &lt;property name="target" ref="personDao"&gt;&lt;/property&gt;
    &lt;property name="transactionManager" ref="transactionManager"&gt;&lt;/property&gt;
    &lt;property name="transactionAttributes"&gt;
        &lt;props&gt;
            &lt;prop key="*"&gt;PROPAGATION_REQUIRED,readOnly&lt;/prop&gt;
            &lt;prop key="save*"&gt;PROPAGATION_REQUIRED&lt;/prop&gt;
        &lt;/props&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>

<p>Semakin banyak class DAO kita, deklarasinya juga akan semakin banyak. Pada aplikasi skala menengah, jumlah DAO bisa mencapai ratusan. Bisa dibayangkan dampaknya terhadap file xml tersebut. Dengan mencantumkan satu baris seperti ini,</p>

<pre><code>&lt;context:component-scan base-package="tutorial.spring25"/&gt;
</code></pre>

<p>Spring dapat secara otomatis memeriksa seluruh package tutorial.spring dan mendaftarkan semua class yang memiliki annotation @Component, @Repository, @Service, dan @Controller.</p>

<p>Kita sudah lihat bagaimana keseluruhan kode program ditulis. Kecuali implementasi sebenarnya tentu saja. Sebelum melihat secara detail bagaimana kode program untuk INSERT dan SELECT, terlebih dulu kita lihat bagaimana class PersonDaoSpringJdbc ini digunakan.</p>

<p>Daripada menggunakan cara yang kurang berwawasan (menggunakan method main), saya akan mengambil pendekatan yang lebih berpendidikan, yaitu menggunakan Unit Test. Lihat <a href="http://endy.artivisi.com/blog/java/ruthless-testing-1/">artikel saya tentang Unit Test dan Integration Test</a> untuk memahami kode berikut.</p>

<p>Ini adalah kerangka class test untuk PersonDaoSpringJdbc. Class ini dibuat dengan menggunakan JUnit 4. Isinya masih belum lengkap. Kita akan lengkapi sambil jalan.</p>

<h3>PersonDaoSpringJdbcTest.java</h3>

<pre><code>package test.spring25.dao.springjdbc
public class PersonDaoSpringJdbcTest {

  private static final ApplicationContext applicationContext;
  private static final DataSource dataSource;
  private static final PersonDao personDao;

  @BeforeClass public static void init(){}
  @Before public void resetDatabase(){}

  @Test public void testGetById(){}
  @Test public void testGetAll(){}
  @Test public void testSave(){}
}
</code></pre>

<p>Seperti kita lihat, kita sudah menggunakan annotation untuk menandai method test dan inisialisasi. Penjelasan tentang JUnit 4 akan dibahas pada artikel terpisah.</p>

<p>Sekarang kita lihat isi masing-masing method. Method init isinya seperti ini.</p>

<pre><code>@BeforeClass public static void init(){
  ctx = new ClassPathXmlApplicationContext("applicationContext.xml");
  dataSource = (DataSource) ctx.getBean("dataSource");
  personDao = (PersonDao) ctx.getBean("personDao");
}
</code></pre>

<p>Method resetDatabase dijalankan sebelum masing-masing test method. Fungsinya untuk menghapus isi tabel T_PERSON dan mengisi sampel data sesuai yang kita inginkan. Ini dilakukan menggunakan DBUnit. Isinya sebagai berikut</p>

<pre><code>@Before public void resetDatabase() throws Exception {
  final Connection conn = ds.getConnection();
  DatabaseOperation.CLEAN_INSERT.execute(new DatabaseConnection(conn), new FlatXmlDataSet(new FileInputStream("fixtures/person.xml")));
  conn.close();
}
</code></pre>

<p>Method ini akan menggunakan sampel data yang ada di file person.xml. Isinya seperti ini,</p>

<pre><code>&lt;dataset&gt;
  &lt;T_PERSON
    id="100"
    name="Endy Muhardin"
    email="endy.muhardin@gmail.com" 
  /&gt;
&lt;/dataset&gt;
</code></pre>

<p>Cukup satu record saja.</p>

<p>Pertama kali, kita akan implementasi method getById. Isi testnya tidak rumit. Cukup jalankan method getById dan periksa hasilnya.</p>

<pre><code>@Test public void testGetById() throws Exception {
  Person endy = personDao.getById(100L);
  assertEquals("Endy Muhardin", endy.getName());
  assertEquals("endy.muhardin@gmail.com", endy.getEmail());
}
</code></pre>

<p>Implementasi getById dalam PersonDaoSpringJdbc seperti ini.</p>

<pre><code>public Person getById(Long id) {
  return simpleJdbcTemplate.queryForObject("select * from T_PERSON where id=?", new PersonMapper(), id);
}
</code></pre>

<p>Cukup satu baris saja.</p>

<p>Method ini membutuhkan class PersonMapper untuk mengkonversi object ResultSet menjadi object Person. Class ini dibuat menjadi static final inner class dalam PersonDaoSpringJdbc.</p>

<pre><code>public class PersonDaoSpringJdbc implements PersonDao {
  private static final class PersonMapper implements ParameterizedRowMapper&lt;Person&gt;{
    @Override
    public Person mapRow(final ResultSet rs, final int rowNum) throws SQLException {
      final Person result = new Person();
      result.setId(rs.getLong("id"));
      result.setName(rs.getString("name"));
      result.setEmail(rs.getString("email"));
      return result;
    }
  }
}
</code></pre>

<p>Selanjutnya, kita akan implementasikan method getAll. Berikut test methodnya.</p>

<pre><code>@Test public void testGetAll() throws Exception {
  List&lt;Person&gt; result = personDao.getAll();
  assertEquals(1, result.size());
  Person endy = result.get(0);
  assertEquals("Endy Muhardin", endy.getName());
  assertEquals("endy.muhardin@gmail.com", endy.getEmail());
}
</code></pre>

<p>Dan ini implementasi dari method getAll.</p>

<pre><code>public List&lt;Person&gt; getAll() {
  return simpleJdbcTemplate.query("select * from T_PERSON", new PersonMapper(), new HashMap&lt;String, String&gt;());
}
</code></pre>

<p>Terakhir, mari kita implementasi method save. Method testnya sedikit lebih panjang, karena untuk yakin akan hasilnya, kita harus melakukan query ke database dengan JDBC murni.</p>

<pre><code>@Test public void testSave() throws Exception {
  Person dhiku = new Person();
  dhiku.setName("Hadikusuma Wahab");
  dhiku.setEmail("dhiku@gmail.com");
  assertNull(dhiku.getId());
  personDao.save(dhiku);
  assertNotNull(dhiku.getId());

  final Connection conn = ds.getConnection();
  final PreparedStatement ps = conn.prepareStatement("select * from T_PERSON where id=?");
  ps.setLong(1, dhiku.getId());
  final ResultSet rs = ps.executeQuery();
  assertTrue(rs.next());

  assertEquals(dhiku.getName(), rs.getString("name"));
  assertEquals(dhiku.getEmail(), rs.getString("email"));

  ps.close();
  rs.close();
  conn.close();
}
</code></pre>

<p>Untungnya implementasi method save juga hanya satu baris.</p>

<pre><code>@Transactional(readOnly=false)
public void save(final Person person) {
  person.setId(simpleJdbcInsert.executeAndReturnKey(new BeanPropertySqlParameterSource(person)).longValue());
}
</code></pre>

<p>Ada beberapa hal yang perlu dijelaskan dari kode di atas.
Pertama, kita perlu mengaktifkan transaksi database untuk mengubah isi database. Kita lakukan dengan @Transactional(readOnly=false).</p>

<p>Kedua, kita bisa menggunakan fitur terbaru Spring JDBC, yaitu SimpleJdbcInsert. Fitur ini mampu melihat ke dalam database dan mengambil daftar nama fieldnya. Object ini diinisialisasi pada saat kita menginjeksi DataSource. Berikut kodenya.</p>

<pre><code>@Autowired
public void setDataSource(final DataSource dataSource) {
  this.simpleJdbcTemplate = new SimpleJdbcTemplate(dataSource);
  this.simpleJdbcInsert = new SimpleJdbcInsert(dataSource).withTableName("T_PERSON").usingGeneratedKeyColumns("id");
}
</code></pre>

<p>Pada saat menginisialisasi object SimpleJdbcInsert kita memberi tahu Spring tentang nama tabel dan field yang isinya autogenerated, misalnya id.</p>

<p>Selama nama field dalam T_PERSON sama dengan nama properti di class Person, kita bisa menghilangkan kode untuk mapping properti ke PreparedStatement. Kode yang biasanya tiga baris seperti ini</p>

<pre><code>PreparedStatement ps = conn.prepareStatement("insert into T_PERSON (name, email) values(?,?)");
ps.setString(1, person.getName());
ps.setString(2, person.getEmail());
</code></pre>

<p>Dapat direduksi menjadi satu baris seperti ini:</p>

<pre><code>SqlParameterSource parameterSource = new BeanPropertySqlParameterSource(person);
</code></pre>

<p>Object parameterSource ini bisa langsung diumpankan ke simpleJdbcInsert seperti ini untuk melakukan insert sekaligus mengambil nilai id yang digenerate database.</p>

<pre><code>Long newId = simpleJdbcInsert.executeAndReturnKey(parameterSource).longValue()
</code></pre>

<p>Fitur SimpleJdbcInsert ini sangat bermanfaat kalau entity class kita terdiri dari puluhan field. Adanya method executeAndReturnKey untuk mengambil auto-generated primary key dari database juga akan sangat membantu kita untuk menghilangkan perbedaan antar database. Biasanya masing-masing merek database memiliki cara yang berbeda-beda untuk mengambil nilai ini.</p>

<p>Sebagai contoh, bila kita lakukan secara manual untuk database MySQL, kodenya akan tampak seperti ini.</p>

<pre><code>@Transactional(readOnly=false)
public void save(final Person person) {
  simpleJdbcInsert.execute(new BeanPropertySqlParameterSource(person));
  Long newId = simpleJdbcInsert.getJdbcOperations().queryForLong("select last_insert_id()");
  person.setId(newId);
}
</code></pre>

<p>Demikianlah sekilas tentang penggunaan fitur Spring terbaru untuk mengakses database. Pada artikel selanjutnya, kita akan lihat fitur-fitur baru di sisi MVC framework.</p>
</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">Endy Muhardin</span></span>

      








  


<time datetime="2007-12-03T21:12:07+07:00" pubdate data-updated="true">Dec 3<span>rd</span>, 2007</time>
      

<span class="categories">
  
    <a class='category' href='/categories/java/'>java</a>
  
</span>


    </p>
    
      <div class="sharing">
  
  <a href="http://twitter.com/share" class="twitter-share-button" data-url="http://endy.artivisi.com/blog/java/akses-database-spring25/" data-via="endymuhardin" data-counturl="http://endy.artivisi.com/blog/java/akses-database-spring25/" >Tweet</a>
  
  
  <div class="g-plusone" data-size="medium"></div>
  
  
    <div class="fb-like" data-send="true" data-width="450" data-show-faces="false"></div>
  
</div>

    
    <p class="meta">
      
        <a class="basic-alignment left articlenav" href="/aplikasi/redmine/" title="Previous Post: Mengelola Proyek dengan Redmine">&laquo; Mengelola Proyek dengan Redmine</a>
      
      
        <a class="basic-alignment right articlenav" href="/java/aplikasi-web-spring25-1/" title="Next Post: Aplikasi Web dengan Spring 2.5 [bagian 1]">Aplikasi Web dengan Spring 2.5 [bagian 1] &raquo;</a>
      
    </p>
  </footer>
</article>

  <section>
    <h1>Comments</h1>
    <div id="facebook_comments" aria-live="polite">
      <noscript>Please enable JavaScript to view the comments powered by facebook</a></noscript>
<div
  class="fb-comments"
  data-href="http://endy.artivisi.com/blog/java/akses-database-spring25/"
  data-num-posts="2"
  data-width="470"
  data-colorscheme="light" ></div>

    </div>
  </section>


</div>

<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/aplikasi/terima-kasih-wordpress/">Terima kasih Wordpress</a>
      </li>
    
      <li class="post">
        <a href="/java/konsep-dasar-log4/">Konsep Dasar Log4j</a>
      </li>
    
      <li class="post">
        <a href="/java/monitoring-aplikasi-java/">Monitoring Aplikasi Java</a>
      </li>
    
      <li class="post">
        <a href="/linux/backup-home-folder/">Backup Home Folder</a>
      </li>
    
      <li class="post">
        <a href="/java/staged-deployment/">Staged Deployment</a>
      </li>
    
      <li class="post">
        <a href="/manajemen/meluruskan-mitos-cmmi/">Meluruskan Mitos CMMI</a>
      </li>
    
      <li class="post">
        <a href="/aplikasi/redmine-jruby-tomca/">Instalasi Redmine di Tomcat</a>
      </li>
    
      <li class="post">
        <a href="/aplikasi/instalasi-spket-ide/">Instalasi Spket IDE</a>
      </li>
    
      <li class="post">
        <a href="/aplikasi/linux/membuat-screencast/">Membuat Screencast</a>
      </li>
    
      <li class="post">
        <a href="/javascript/tutorial-extjs/">Tutorial ExtJS</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>Latest Tweets</h1>
  <ul id="tweets">
    <li class="loading">Status updating...</li>
  </ul>
  <script type="text/javascript">
    $.domReady(function(){
      getTwitterFeed("endymuhardin", 4, false);
    });
  </script>
  <script src="/javascripts/twitter.js" type="text/javascript"> </script>
  
    <a href="http://twitter.com/endymuhardin" class="twitter-follow-button" data-show-count="false">Follow @endymuhardin</a>
  
</section>



<section class="googleplus">
  <h1>
    <a href="https://plus.google.com/110971146012275775230?rel=author">
      <img src="http://www.google.com/images/icons/ui/gprofile_button-32.png" width="32" height="32">
      Google+
    </a>
  </h1>
</section>



  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2012 - Endy Muhardin -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  



<div id="fb-root"></div>
<script>(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) {return;}
  js = d.createElement(s); js.id = id;
  js.src = "//connect.facebook.net/en_US/all.js#appId=269506799827290&xfbml=1";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>



  <script type="text/javascript">
    (function() {
      var script = document.createElement('script'); script.type = 'text/javascript'; script.async = true;
      script.src = 'https://apis.google.com/js/plusone.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(script, s);
    })();
  </script>



  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = 'http://platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
