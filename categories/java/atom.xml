<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: java | Living life and make it better]]></title>
  <link href="http://software.endy.muhardin.com/categories/java/atom.xml" rel="self"/>
  <link href="http://software.endy.muhardin.com/"/>
  <updated>2013-05-10T14:12:20+07:00</updated>
  <id>http://software.endy.muhardin.com/</id>
  <author>
    <name><![CDATA[Endy Muhardin]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Mencari Relasi Foreign Key ke Tabel MySQL]]></title>
    <link href="http://software.endy.muhardin.com/java/mencari-relasi-foreign-key-ke-tabel-mysql/"/>
    <updated>2013-02-07T15:24:00+07:00</updated>
    <id>http://software.endy.muhardin.com/java/mencari-relasi-foreign-key-ke-tabel-mysql</id>
    <content type="html"><![CDATA[<p>Di aplikasi yang kita buat, biasanya ada fitur untuk menghapus data atau record tertentu.
Bila kita menggunakan database relasional yang memiliki fitur <em>referential integrity</em>,
kita akan dicegah bila data yang ingin kita hapus memiliki relasi ke data lain.</p>

<p>Contohnya, kita punya tabel <code>Produk</code>, yang kolom <code>id</code>nya digunakan sebagai <em>foreign key</em>
oleh tabel <code>Penjualan</code>.
Dengan demikian, pada waktu ingin menghapus data <code>Produk</code>, terlebih dulu kita cek ke tabel
<code>Penjualan</code>, apakah ada data transaksi yang berelasi ke <code>Produk</code> yang ingin kita hapus.</p>

<p>Akan menjadi masalah bila aplikasi kita sudah besar, tabelnya ada ratusan.
Bagaimana cara kita mencari tabel mana saja yang memiliki relasi ke tabel <code>Produk</code>?
Tentunya tidak mungkin dicek satu-persatu.</p>

<p>Dengan bantuan paman Google, berikut adalah cara mendapatkannya untuk database MySQL.</p>

<!--more-->


<p>Pertama, login dulu ke MySQL</p>

<p><code>
mysql -u root -p
Password:
mysql&gt;
</code></p>

<p>Kemudian, gunakan database <code>information_schema</code></p>

<p><code>
use information_schema
</code></p>

<p>Terakhir, jalankan query SQL berikut</p>

<p><code>sql
SELECT TABLE_NAME,COLUMN_NAME,CONSTRAINT_NAME,
REFERENCED_TABLE_NAME,REFERENCED_COLUMN_NAME
FROM KEY_COLUMN_USAGE
WHERE REFERENCED_TABLE_NAME = 'produk'
AND REFERENCED_COLUMN_NAME = 'id'
AND TABLE_SCHEMA='db_penjualan';
</code></p>

<p>Inilah hasilnya</p>

<p><code>
+-------------------------------------------------------------------------------------------+
| TABLE_NAME         | COLUMN_NAME | CONSTRAINT_NAME     | REFERENCED_TABLE_NAME | REFERENCED_COLUMN_NAME |
+-------------------------------------------------------------------------------------------+
| penjualan          | id_produk   | fk_penjualan_produk | produk                | id                     |
| stok               | id_produk   | fk_stok_produk      | produk                | id                     |
+-------------------------------------------------------------------------------------------+
</code></p>

<p>Penjelasan:</p>

<ul>
<li>Table Name : Nama Tabel yang memiliki referensi</li>
<li>Column Name : Nama Kolom yang merupakan <em>foreign key</em></li>
<li>Constraint Name : Nama constraint <em>foreign key</em></li>
<li>Referenced Table Name : Nama tabel yang dituju</li>
<li>Referenced Column Name : Nama kolom yang dituju <em>foreign key</em></li>
</ul>


<p>Demikian sekilas tutorial. Semoga bermanfaat dalam membuat validasi.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Memahami Dependency Injection]]></title>
    <link href="http://software.endy.muhardin.com/java/memahami-dependency-injection/"/>
    <updated>2013-01-24T18:14:00+07:00</updated>
    <id>http://software.endy.muhardin.com/java/memahami-dependency-injection</id>
    <content type="html"><![CDATA[<p><a href="http://www.springsource.org/spring-framework">Spring Framework</a>
merupakan framework yang sangat populer
dan banyak digunakan orang di seluruh dunia.
Jargon utama yang sering kita dengar bersamaan dengan Spring Framework
adalah prinsip <em>Dependency Injection</em>. Ini adalah teknik pemrograman
yang digadang-gadang mampu merapikan aplikasi yang kita buat sehingga
mudah dipahami dan dikelola.</p>

<p>Tapi apakah yang dimaksud dengan <em>Dependency Injection</em> atau <em>Inversion of Control</em> itu?</p>

<!--more-->


<h1>Contoh Kasus</h1>

<p>Sebagai programmer, kita akan lebih mudah memahami suatu konsep
bila sudah melihat sendiri contoh kode program dan aplikasinya.
Untuk itu, kita akan membuat sebuah contoh kasus sederhana,
yaitu menyimpan data ke tabel <code>produk</code> dalam database.</p>

<p>Untuk titik awal, misalnya kita memiliki class <code>Produk</code> sebagai berikut:</p>

<h2>Produk.java</h2>

<p>```java
public class Produk {</p>

<pre><code>private Integer id;
private String kode;
private String nama;
private BigDecimal harga;

// getter dan setter tidak ditampilkan
</code></pre>

<p>}
```</p>

<p>Supaya rapi, kode program untuk Create (insert), Read (select),
Update, dan Delete (CRUD), akan kita kumpulkan di dalam class <code>ProdukDao</code> sebagai berikut:</p>

<h2>ProdukDao.java</h2>

<p>```java
public class ProdukDao {</p>

<pre><code>private DataSource dataSource;

public void create(Produk p) throws Exception {
    String sql = "insert into produk (kode, nama, harga) ";
    sql += "(?,?,?)";

    Connection databaseConnection = dataSource.getConnection();
    PreparedStatement ps = databaseConnection.prepareStatement(sql);
    ps.setString(1, p.getKode());
    ps.setString(2, p.getNama());
    ps.setBigDecimal(3, p.getHarga());
    ps.executeUpdate();
    databaseConnection.close();
}

public Produk cariById(Integer id){
    // implementasi tidak ditulis
}


public void update(Produk p){
    // implementasi tidak ditulis
}


public void delete(Produk p){
    // implementasi tidak ditulis
}
</code></pre>

<p>}
```</p>

<p>Sebagai demonstrasi, kita akan menggunakan/memanggil <code>ProdukDao</code> ini dalam class
<code>ProdukDaoTest</code> sebagai berikut:</p>

<h2>ProdukDaoTest.java</h2>

<p>```java
public class ProdukDaoTest {</p>

<pre><code>public static void main(String[] xx){
    Produk p = new Produk();
    p.setKode("P-001");
    p.setNama("Produk 001");
    p.setHarga(new BigDecimal(10000.00);

    ProdukDao pd = new ProdukDao();
    pd.simpan(p);
}
</code></pre>

<p>}
```</p>

<p>Dari ketiga class di atas, kita akan melihat:</p>

<ul>
<li>bagaimana implementasi tanpa Dependency Injection</li>
<li>bagaimana konsep Dependency Injection</li>
<li>bagaimana menggunakan Spring Framework untuk melakukan Dependency Injection</li>
</ul>


<p>Sebelumnya, apa itu dependency injection? Kalau diterjemahkan ke bahasa Indonesia,
kira-kira artinya adalah <em>menyediakan kebutuhan</em>.
Kebutuhan apa yang dimaksud?</p>

<p>Coba lihat class <code>ProdukDao</code>. Untuk bisa menjalankan tugasnya dengan baik,
dia membutuhkan object <code>DataSource</code>, yaitu koneksi ke database.
Bagaimana <code>ProdukDao</code> mendapatkan <code>DataSource</code> inilah yang menjadi pembahasan dalam <em>Dependency Injection</em> (DI).</p>

<h1>Tanpa DI</h1>

<p>Kalau kita tidak menggunakan prinsip DI, maka <code>ProdukDao</code> harus mengadakan sendiri object <code>DataSource</code>.
Kira-kira begini implementasinya:</p>

<p>```java
public class ProdukDao {</p>

<pre><code>private DataSource dataSource;

public ProdukDao() throws Exception {
    dataSource = new BasicDataSource();
    dataSource.setDriverClassName("com.mysql.jdbc.Driver");
    dataSource.setUsername("root");
    dataSource.setPassword("admin");
    dataSource.setUrl("jdbc:mysql://localhost/belajar");
}

public void create(Produk p) throws Exception {
    String sql = "insert into produk (kode, nama, harga) ";
    sql += "(?,?,?)";

    Connection databaseConnection = dataSource.getConnection();
    PreparedStatement ps = databaseConnection.prepareStatement(sql);
    ps.setString(1, p.getKode());
    ps.setString(2, p.getNama());
    ps.setBigDecimal(3, p.getHarga());
    ps.executeUpdate();
    databaseConnection.close();
}

public Produk cariById(Integer id){
    // implementasi tidak ditulis
}


public void update(Produk p){
    // implementasi tidak ditulis
}


public void delete(Produk p){
    // implementasi tidak ditulis
}
</code></pre>

<p>}
```</p>

<p>Perlu kita sadari bahwa pada aplikasi yang sebenarnya, kode akses database tidak hanya <code>ProdukDao</code> saja.
Nantinya juga ada <code>CustomerDao</code>, <code>PenjualanDao</code>, dan sebagainya.
Di aplikasi berskala menengah, bisa ada ratusan class seperti ini,
sehingga untuk memahami situasinya, kita tidak boleh berpikir hanya di satu class ini saja.</p>

<p>Ada beberapa kelemahan dari cara tanpa DI ini, diantaranya:</p>

<ul>
<li>Konfigurasi koneksi database tersebar di banyak tempat, yaitu di semua <code>XxxDao</code></li>
<li>Object <code>dataSource</code> juga tersebar, tidak bisa satu <code>dataSource</code> dipakai bersama oleh semua <code>XxxDao</code></li>
<li>Karena konfigurasi dan inisialisasinya tersebar, bila ada perubahan (misalnya menggunakan <em>connection pooling</em>),
harus dilakukan di banyak tempat.</li>
<li>Semua perubahan di atas mengharuskan full compile karena banyaknya class yang terlibat.</li>
</ul>


<p>Untuk mengatasi keterbatasan di atas, kita gunakan prinsip DI.</p>

<h1>DI manual</h1>

<p>Bila kita gunakan prinsip DI, maka <code>ProdukDao</code> tidak lagi mengurus inisialisasi <code>dataSource</code>.
Dia cukup tahu beres dan tinggal pakai. Lalu siapa yang melakukan inisialisasi?
Boleh siapa saja, tapi untuk kesederhanaan ilustrasi, mari kita tulis saja di dalam <code>ProdukDaoTest</code>, sebagai berikut:</p>

<p>```java
public class ProdukDaoTest {</p>

<pre><code>public static void main(String[] xx){
    Produk p = new Produk();
    p.setKode("P-001");
    p.setNama("Produk 001");
    p.setHarga(new BigDecimal(10000.00);

    DataSource dataSource = new BasicDataSource();
    dataSource.setDriverClassName("com.mysql.jdbc.Driver");
    dataSource.setUsername("root");
    dataSource.setPassword("admin");
    dataSource.setUrl("jdbc:mysql://localhost/belajar");

    ProdukDao pd = new ProdukDao();
    pd.simpan(p);
}
</code></pre>

<p>}
```</p>

<p>Lalu bagaimana cara memasukkan (inject) ke dalam <code>ProdukDao</code>?
Kita harus sediakan jalan masuknya. Ada dua pilihan:</p>

<ul>
<li>membuat method untuk mengisi data (setter-injection)</li>
<li>menambah argumen di constructor (constructor-injection)</li>
</ul>


<p>Agar jelas, kita akan buatkan dua-duanya.</p>

<p>```java
public class ProdukDao {</p>

<pre><code>private DataSource dataSource;

// ini kalau mau inject melalui constructor
public ProdukDao(DataSource ds) {
    this.dataSource = ds;
}

// ini kalau mau method sendiri (setter-injection)
public void setDataSource(DataSource ds) {
    this.dataSource = ds;
}

// method lain tidak ditampilkan supaya tidak bikin penuh
</code></pre>

<p>}
```</p>

<p>Selanjutnya, dalam <code>ProdukDaoTest</code> kita bisa isikan object DataSource tersebut melalui constructor seperti ini:</p>

<p><code>java
ProdukDao pd = new ProdukDao(dataSource);
</code></p>

<p>ataupun melalui method setter seperti ini:</p>

<p><code>java
ProdukDao pd = new ProdukDao();
pd.setDataSource(dataSource);
</code></p>

<p>Cara manual ini sudah lumayan merapikan kode program kita, karena bila ada perubahan terhadap inisialisasi dataSource, seperti misalnya:</p>

<ul>
<li>perubahan konfigurasi koneksi</li>
<li>perubahan implementasi connection pooling</li>
<li>ingin menggunakan managed DataSource melalui JNDI</li>
<li>dsb</li>
</ul>


<p>Kita cukup melakukan perubahan di satu tempat saja, yaitu dimana dia diinisialisasikan.</p>

<h1>DI Spring XML</h1>

<p>Walaupun bisa dilakukan secara manual, tetapi ada baiknya kita menggunakan Spring Framework untuk melakukan DI.
Beberapa alasannya antara lain:</p>

<ul>
<li>AOP (tidak dibahas pada artikel ini)</li>
<li>keseragaman antar project/aplikasi</li>
<li>standarisasi skillset. Bila cari programmer baru, cukup mensyaratkan pengetahuan Spring Framework.
Tidak perlu lagi ditraining tentang teknik DI yang kita karang sendiri.</li>
</ul>


<p>Spring Framework <strong>umumnya</strong> dikonfigurasi dengan file XML (walaupun bisa juga full Java).
Berikut adalah contoh file konfigurasinya, misalnya kita beri nama <code>konfig-spring.xml</code>:</p>

<p>```xml
&lt;?xml version="1.0" encoding="UTF-8"?>
&lt;beans xmlns="http://www.springframework.org/schema/beans"</p>

<pre><code>xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xmlns:context="http://www.springframework.org/schema/context"
xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
    http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt;

&lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource"&gt;
    &lt;property name="driverClassName" value="com.mysql.jdbc.Driver" /&gt;
    &lt;property name="url" value="jdbc:mysql://localhost/belajar" /&gt;
    &lt;property name="username" value="root" /&gt;
    &lt;property name="password" value="admin" /&gt;
&lt;/bean&gt;

&lt;bean id="produkDao" class="com.muhardin.endy.belajar.spring.ProdukDao"&gt;
    &lt;property name="dataSource" ref="dataSource"/&gt;
&lt;/bean&gt;
</code></pre>

<p></beans>
```</p>

<p>File konfigurasi tersebut kita baca dan gunakan dalam class <code>ProdukDaoTest</code>,
perhatikan perbedaan inisialisasi <code>DataSource</code> dan <code>ProdukDao</code></p>

<p>```java
public class ProdukDaoTest {</p>

<pre><code>public static void main(String[] xx){
    Produk p = new Produk();
    p.setKode("P-001");
    p.setNama("Produk 001");
    p.setHarga(new BigDecimal(10000.00);

    ApplicationContext ctx 
        = new ClassPathXmlApplicationContext("classpath:konfig-spring.xml");

    ProdukDao pd = ctx.getBean(ProdukDao.class);
    pd.simpan(p);
}
</code></pre>

<p>}
```</p>

<p>Pada contoh di atas, kita bisa lihat beberapa perbedaan yaitu:</p>

<ul>
<li>inisialisasi <code>DataSource</code> pindah ke dalam <code>konfig-spring.xml</code></li>
<li>tidak perlu lagi <em>mengisikan</em> <code>DataSource</code> ke dalam <code>ProdukDao</code>, karena sudah dilakukan oleh Spring.</li>
</ul>


<p>Walaupun demikian, masih ada sedikit ganjalan, yaitu:</p>

<ul>
<li>bila <code>XxxDao</code> jumlahnya ratusan, maka file <code>konfig-spring.xml</code> akan membengkak.</li>
</ul>


<p>Apa solusinya?</p>

<h1>DI Spring @Autowired</h1>

<p>Spring Framework menyediakan fitur <em>component-scan</em>, yaitu dia akan melihat isi <em>package</em> yang kita sebutkan,
kemudian akan mencari class-class yang diberi anotasi berikut:</p>

<ul>
<li><code>@Repository</code></li>
<li><code>@Service</code></li>
<li><code>@Controller</code></li>
<li><code>@Component</code></li>
</ul>


<p>Setelah ditemukan, maka dia akan melakukan inisialisasi terhadap class tersebut, dan lalu mengisi (inject)
semua kebutuhannya (dependency). Untuk injection ini, kita juga tidak perlu lagi menyediakan setter method maupun
menambahkan argumen di constructor. Kita dapat menggunakan anotasi <code>@Autowired</code>.</p>

<p>Berikut adalah konfigurasi <code>konfig-spring.xml</code> yang baru:</p>

<p>```xml
&lt;?xml version="1.0" encoding="UTF-8"?>
&lt;beans xmlns="http://www.springframework.org/schema/beans"</p>

<pre><code>xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xmlns:context="http://www.springframework.org/schema/context"
xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
    http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt;

&lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource"&gt;
    &lt;property name="driverClassName" value="com.mysql.jdbc.Driver" /&gt;
    &lt;property name="url" value="jdbc:mysql://localhost/belajar" /&gt;
    &lt;property name="username" value="root" /&gt;
    &lt;property name="password" value="admin" /&gt;
&lt;/bean&gt;

&lt;context:component-scan base-package="com.muhardin.endy.belajar.spring" /&gt;
</code></pre>

<p></beans>
```</p>

<p>Perhatikan bahwa deklarasi <code>produkDao</code> telah digantikan dengan perintah <code>context:component-scan</code>.</p>

<p>Berikut adalah perubahan di <code>ProdukDao</code></p>

<p>```java
@Repository
public class ProdukDao {</p>

<pre><code>@Autowired private DataSource dataSource;

public void create(Produk p){
    String sql = "insert into produk (kode, nama, harga) ";
    sql += "(?,?,?)";

    Connection databaseConnection = dataSource.getConnection();
    PreparedStatement ps = databaseConnection.prepareStatement(sql);
    ps.setString(1, p.getKode());
    ps.setString(2, p.getNama());
    ps.setBigDecimal(3, p.getHarga());
    ps.executeUpdate();
    databaseConnection.close();
}

// method lain tidak ditampilkan supaya tidak bikin penuh
</code></pre>

<p>}
```</p>

<p>Perhatikan bahwa setter dan constructor injection sudah dihapus,
dan digantikan dengan anotasi <code>@Autowired</code>.
Semua field/property yang memiliki anotasi <code>@Autowired</code> akan diisikan oleh Spring dengan object bertipe-data sesuai.
Bila tidak ditemukan, maka aplikasi akan gagal start dengan pesan error seperti ini:</p>

<p><code>
SEVERE: Context initialization failed
org.springframework.beans.factory.BeanCreationException:
Error creating bean with name 'produkDao':
Injection of autowired dependencies failed;
nested exception is org.springframework.beans.factory.BeanCreationException:
Could not autowire field:
private javax.sql.DataSource dataSource;
nested exception is org.springframework.beans.factory.NoSuchBeanDefinitionException:
No matching bean of type [javax.sql.DataSource] found for dependency:
expected at least 1 bean which qualifies as autowire candidate for this dependency.
</code></p>

<p>Bila menemukan pesan error tersebut, artinya Spring tidak memiliki satupun object bertipe <code>DataSource</code>
dalam daftar pengelolaannya. Untuk bisa dikelola oleh Spring, ada beberapa caranya, yaitu:</p>

<ul>
<li>dideklarasikan secara tertulis seperti object <code>dataSource</code> di atas</li>
<li>discan otomatis melalui <code>component-scan</code> dan anotasi <code>@Repository</code>, <code>@Service</code>, <code>@Controller</code>, ataupun<code>@Component</code>.
Contohnya object <code>produkDao</code> di atas.</li>
</ul>


<p>Ada beberapa kesalahan yang umum terjadi sehingga muncul pesan error di atas, diantaranya</p>

<ul>
<li>sudah ada anotasi, tapi package tempatnya berada tidak didaftarkan dalam <code>component-scan</code></li>
<li>package sudah didaftarkan dalam <code>component-scan</code>, tapi classnya tidak diberikan anotasi <code>@Repository</code>, <code>@Service</code>, <code>@Controller</code>, ataupun<code>@Component</code>.</li>
<li>sudah ada anotasi, packagenya sudah didaftarkan, tapi file xml yang memuat konfigurasi tersebut tidak diload oleh aplikasi.
Ini biasa terjadi kalau satu aplikasi terdiri dari banyak file konfigurasi Spring (yang mana ini adalah hal yang umum terjadi)</li>
</ul>


<p>Lalu kapan dan bagaimana Spring membaca file konfigurasi? Ada beberapa cara:</p>

<ul>
<li>Ditulis dalam kode program : <code>new ClassPathXmlApplicationContext("classpath:konfig-spring.xml")</code></li>
<li>Bila aplikasinya berbasis web, biasanya diinisialisasi melalui <code>web.xml</code> seperti ini:</li>
</ul>


<p>```xml
<context-param></p>

<pre><code>&lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
&lt;param-value&gt;
    classpath*:konfig-spring.xml
&lt;/param-value&gt;
</code></pre>

<p></context-param>
<listener></p>

<pre><code>&lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;
</code></pre>

<p></listener>
```</p>

<p>Demikianlah penjelasan tentang konsep Dependency Injection dan Spring Framework. Semoga bermanfaat.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Membuat Changelog Liquibase]]></title>
    <link href="http://software.endy.muhardin.com/java/membuat-changelog-liquibase/"/>
    <updated>2013-01-10T10:03:00+07:00</updated>
    <id>http://software.endy.muhardin.com/java/membuat-changelog-liquibase</id>
    <content type="html"><![CDATA[<p>Di ArtiVisi, kami menggunakan tools bernama <a href="http://liquibase.org/">Liquibase</a> untuk mendefinisikan skema database.
Dengan Liquibase ini, skema database dapat disimpan dan dikelola versinya dalam Git.
Dia juga memiliki fitur untuk melakukan migrasi database pada saat aplikasi kita naik versi.
Bila terjadi error di versi baru, Liquibase juga bisa melakukan rollback
agar skema database kita kembali ke kondisi sebelum naik versi.</p>

<p>Skema database dalam Liquibase ditulis dalam format XML, disebut dengan istilah <code>changelog</code>.
Untuk project baru, ini bisa ditulis tangan secara manual,
tetapi untuk aplikasi yang sudah ada,
terlalu merepotkan kalau semua tabel yang sudah ada harus ditulis ulang skemanya.</p>

<!--more-->


<p>Untungnya Liquibase memiliki fitur untuk menulis changelog dari skema yang sudah ada.
Berikut langkah-langkahnya:</p>

<ol>
<li>Siapkan jar liquibase dan database</li>
<li>Siapkan file konfigurasi</li>
<li>Jalankan liquibase</li>
<li>Cek hasilnya</li>
</ol>


<h2>Siapkan jar liquibase dan database</h2>

<p>Database yang akan saya import memiliki konfigurasi sebagai berikut:</p>

<ul>
<li>Jenis Database : MySQL</li>
<li>Nama Database : merchant-simulator_development</li>
<li>Username Database : root</li>
<li>Password Database : admin</li>
</ul>


<p>Untuk itu, saya siapkan dua file jar, yaitu :</p>

<ul>
<li>mysql-connector-java-5.1.22.jar</li>
<li>liquibase-core-2.0.5.jar</li>
</ul>


<h2>File Konfigurasi</h2>

<p>Sebetulnya semua informasi ini bisa disebutkan dalam command line argument.
Tapi saya lebih suka menulis di file supaya mudah diedit.
Berikut isinya</p>

<p>```</p>

<h1>liquibase.properties</h1>

<p>driver: com.mysql.jdbc.Driver
classpath: mysql-connector-java-5.1.22.jar
url: jdbc:mysql://localhost/merchant-simulator_development
username: root
password: admin
changeLogFile: liquibase-output.xml
```</p>

<p>Simpan file ini dengan nama <code>liquibase.properties</code> dan letakkan di folder yang sama dengan kedua file jar tersebut.</p>

<h2>Jalankan Liquibase</h2>

<p>Mari kita jalankan proses import dengan command berikut:</p>

<p><code>
java -jar liquibase-core-2.0.5.jar generateChangelog
</code></p>

<h2>Cek Hasilnya</h2>

<p>Perintah di atas akan menghasilkan file <code>liquibase-output.xml</code> yang isinya seperti ini:</p>

<p>```xml
&lt;?xml version="1.0" encoding="UTF-8" standalone="no"?>
<databaseChangeLog xmlns="http://www.liquibase.org/xml/ns/dbchangelog" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.liquibase.org/xml/ns/dbchangelog http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-2.0.xsd"></p>

<pre><code>&lt;changeSet author="endy (generated)" id="1357786892853-1"&gt;
    &lt;createTable tableName="c_application_config"&gt;
        &lt;column name="id" type="VARCHAR(255)"&gt;
            &lt;constraints nullable="false" primaryKey="true"/&gt;
        &lt;/column&gt;
        &lt;column name="name" type="VARCHAR(255)"&gt;
            &lt;constraints nullable="false"/&gt;
        &lt;/column&gt;
        &lt;column name="label" type="VARCHAR(255)"&gt;
            &lt;constraints nullable="false"/&gt;
        &lt;/column&gt;
        &lt;column name="value" type="VARCHAR(255)"&gt;
            &lt;constraints nullable="false"/&gt;
        &lt;/column&gt;
    &lt;/createTable&gt;
&lt;/changeSet&gt;
&lt;changeSet author="endy (generated)" id="1357786892853-2"&gt;
    &lt;createTable tableName="c_security_menu"&gt;
        &lt;column name="id" type="VARCHAR(255)"&gt;
            &lt;constraints nullable="false" primaryKey="true"/&gt;
        &lt;/column&gt;
        &lt;column name="label" type="VARCHAR(255)"&gt;
            &lt;constraints nullable="false"/&gt;
        &lt;/column&gt;
        &lt;column name="menu_action" type="VARCHAR(255)"/&gt;
        &lt;column name="menu_level" type="INT"&gt;
            &lt;constraints nullable="false"/&gt;
        &lt;/column&gt;
        &lt;column name="menu_order" type="INT"&gt;
            &lt;constraints nullable="false"/&gt;
        &lt;/column&gt;
        &lt;column name="menu_options" type="VARCHAR(255)"/&gt;
        &lt;column name="id_parent" type="VARCHAR(255)"/&gt;
    &lt;/createTable&gt;
&lt;/changeSet&gt;
&lt;changeSet author="endy (generated)" id="1357786892853-3"&gt;
    &lt;createTable tableName="c_security_permission"&gt;
        &lt;column name="id" type="VARCHAR(255)"&gt;
            &lt;constraints nullable="false" primaryKey="true"/&gt;
        &lt;/column&gt;
        &lt;column name="permission_label" type="VARCHAR(255)"&gt;
            &lt;constraints nullable="false"/&gt;
        &lt;/column&gt;
        &lt;column name="permission_value" type="VARCHAR(255)"&gt;
            &lt;constraints nullable="false"/&gt;
        &lt;/column&gt;
    &lt;/createTable&gt;
&lt;/changeSet&gt;
&lt;changeSet author="endy (generated)" id="1357786892853-4"&gt;
    &lt;createTable tableName="c_security_role"&gt;
        &lt;column name="id" type="VARCHAR(255)"&gt;
            &lt;constraints nullable="false" primaryKey="true"/&gt;
        &lt;/column&gt;
        &lt;column name="name" type="VARCHAR(255)"&gt;
            &lt;constraints nullable="false"/&gt;
        &lt;/column&gt;
        &lt;column name="description" type="VARCHAR(255)"/&gt;
    &lt;/createTable&gt;
&lt;/changeSet&gt;
&lt;changeSet author="endy (generated)" id="1357786892853-5"&gt;
    &lt;createTable tableName="c_security_role_menu"&gt;
        &lt;column name="id_role" type="VARCHAR(255)"&gt;
            &lt;constraints nullable="false"/&gt;
        &lt;/column&gt;
        &lt;column name="id_menu" type="VARCHAR(255)"&gt;
            &lt;constraints nullable="false"/&gt;
        &lt;/column&gt;
    &lt;/createTable&gt;
&lt;/changeSet&gt;
&lt;changeSet author="endy (generated)" id="1357786892853-6"&gt;
    &lt;createTable tableName="c_security_role_permission"&gt;
        &lt;column name="id_role" type="VARCHAR(255)"&gt;
            &lt;constraints nullable="false"/&gt;
        &lt;/column&gt;
        &lt;column name="id_permission" type="VARCHAR(255)"&gt;
            &lt;constraints nullable="false"/&gt;
        &lt;/column&gt;
    &lt;/createTable&gt;
&lt;/changeSet&gt;
&lt;changeSet author="endy (generated)" id="1357786892853-7"&gt;
    &lt;createTable tableName="c_security_user"&gt;
        &lt;column name="id" type="VARCHAR(255)"&gt;
            &lt;constraints nullable="false" primaryKey="true"/&gt;
        &lt;/column&gt;
        &lt;column name="username" type="VARCHAR(255)"&gt;
            &lt;constraints nullable="false"/&gt;
        &lt;/column&gt;
        &lt;column name="password" type="VARCHAR(255)"&gt;
            &lt;constraints nullable="false"/&gt;
        &lt;/column&gt;
        &lt;column name="fullname" type="VARCHAR(255)"/&gt;
        &lt;column name="active" type="BIT"/&gt;
        &lt;column name="id_role" type="VARCHAR(255)"&gt;
            &lt;constraints nullable="false"/&gt;
        &lt;/column&gt;
    &lt;/createTable&gt;
&lt;/changeSet&gt;
&lt;changeSet author="endy (generated)" id="1357786892853-8"&gt;
    &lt;createTable tableName="t_tagihan_listrik"&gt;
        &lt;column name="id" type="VARCHAR(255)"&gt;
            &lt;constraints nullable="false" primaryKey="true"/&gt;
        &lt;/column&gt;
        &lt;column name="admin" type="DECIMAL(19,2)"&gt;
            &lt;constraints nullable="false"/&gt;
        &lt;/column&gt;
        &lt;column name="bulan_tagihan" type="DATE"&gt;
            &lt;constraints nullable="false"/&gt;
        &lt;/column&gt;
        &lt;column name="current_meter_reading_1" type="VARCHAR(255)"&gt;
            &lt;constraints nullable="false"/&gt;
        &lt;/column&gt;
        &lt;column name="current_meter_reading_2" type="VARCHAR(255)"&gt;
            &lt;constraints nullable="false"/&gt;
        &lt;/column&gt;
        &lt;column name="current_meter_reading_3" type="VARCHAR(255)"&gt;
            &lt;constraints nullable="false"/&gt;
        &lt;/column&gt;
        &lt;column name="denda" type="DECIMAL(19,2)"&gt;
            &lt;constraints nullable="false"/&gt;
        &lt;/column&gt;
        &lt;column name="id_pelanggan" type="VARCHAR(255)"&gt;
            &lt;constraints nullable="false"/&gt;
        &lt;/column&gt;
        &lt;column name="jatuh_tempo" type="DATE"&gt;
            &lt;constraints nullable="false"/&gt;
        &lt;/column&gt;
        &lt;column name="lunas" type="BIT"&gt;
            &lt;constraints nullable="false"/&gt;
        &lt;/column&gt;
        &lt;column name="meter_read_date" type="DATE"&gt;
            &lt;constraints nullable="false"/&gt;
        &lt;/column&gt;
        &lt;column name="mitra_lunas" type="VARCHAR(255)"/&gt;
        &lt;column name="nama_pelanggan" type="VARCHAR(255)"&gt;
            &lt;constraints nullable="false"/&gt;
        &lt;/column&gt;
        &lt;column name="nilai" type="DECIMAL(19,2)"&gt;
            &lt;constraints nullable="false"/&gt;
        &lt;/column&gt;
        &lt;column name="pajak" type="DECIMAL(19,2)"&gt;
            &lt;constraints nullable="false"/&gt;
        &lt;/column&gt;
        &lt;column name="power_consuming_category" type="VARCHAR(255)"&gt;
            &lt;constraints nullable="false"/&gt;
        &lt;/column&gt;
        &lt;column name="previous_meter_reading_1" type="VARCHAR(255)"&gt;
            &lt;constraints nullable="false"/&gt;
        &lt;/column&gt;
        &lt;column name="previous_meter_reading_2" type="VARCHAR(255)"&gt;
            &lt;constraints nullable="false"/&gt;
        &lt;/column&gt;
        &lt;column name="previous_meter_reading_3" type="VARCHAR(255)"&gt;
            &lt;constraints nullable="false"/&gt;
        &lt;/column&gt;
        &lt;column name="referensi_lunas" type="VARCHAR(255)"/&gt;
        &lt;column name="service_unit" type="VARCHAR(255)"&gt;
            &lt;constraints nullable="false"/&gt;
        &lt;/column&gt;
        &lt;column name="service_unit_hone" type="VARCHAR(255)"&gt;
            &lt;constraints nullable="false"/&gt;
        &lt;/column&gt;
        &lt;column name="subscriber_segmentation" type="VARCHAR(255)"&gt;
            &lt;constraints nullable="false"/&gt;
        &lt;/column&gt;
        &lt;column name="waktu_lunas" type="DATETIME"/&gt;
    &lt;/createTable&gt;
&lt;/changeSet&gt;
&lt;changeSet author="endy (generated)" id="1357786892853-9"&gt;
    &lt;addPrimaryKey columnNames="id_role, id_menu" tableName="c_security_role_menu"/&gt;
&lt;/changeSet&gt;
&lt;changeSet author="endy (generated)" id="1357786892853-10"&gt;
    &lt;addPrimaryKey columnNames="id_role, id_permission" tableName="c_security_role_permission"/&gt;
&lt;/changeSet&gt;
&lt;changeSet author="endy (generated)" id="1357786892853-11"&gt;
    &lt;addForeignKeyConstraint baseColumnNames="id_parent" baseTableName="c_security_menu" baseTableSchemaName="merchant-simulator_development" constraintName="fk_menu_parent" deferrable="false" initiallyDeferred="false" onDelete="NO ACTION" onUpdate="NO ACTION" referencedColumnNames="id" referencedTableName="c_security_menu" referencedTableSchemaName="merchant-simulator_development" referencesUniqueColumn="false"/&gt;
&lt;/changeSet&gt;
&lt;changeSet author="endy (generated)" id="1357786892853-12"&gt;
    &lt;addForeignKeyConstraint baseColumnNames="id_menu" baseTableName="c_security_role_menu" baseTableSchemaName="merchant-simulator_development" constraintName="fk_role_menu_menu" deferrable="false" initiallyDeferred="false" onDelete="NO ACTION" onUpdate="NO ACTION" referencedColumnNames="id" referencedTableName="c_security_menu" referencedTableSchemaName="merchant-simulator_development" referencesUniqueColumn="false"/&gt;
&lt;/changeSet&gt;
&lt;changeSet author="endy (generated)" id="1357786892853-13"&gt;
    &lt;addForeignKeyConstraint baseColumnNames="id_role" baseTableName="c_security_role_menu" baseTableSchemaName="merchant-simulator_development" constraintName="fk_role_menu_role" deferrable="false" initiallyDeferred="false" onDelete="NO ACTION" onUpdate="NO ACTION" referencedColumnNames="id" referencedTableName="c_security_role" referencedTableSchemaName="merchant-simulator_development" referencesUniqueColumn="false"/&gt;
&lt;/changeSet&gt;
&lt;changeSet author="endy (generated)" id="1357786892853-14"&gt;
    &lt;addForeignKeyConstraint baseColumnNames="id_permission" baseTableName="c_security_role_permission" baseTableSchemaName="merchant-simulator_development" constraintName="fk_role_permission_permission" deferrable="false" initiallyDeferred="false" onDelete="NO ACTION" onUpdate="NO ACTION" referencedColumnNames="id" referencedTableName="c_security_permission" referencedTableSchemaName="merchant-simulator_development" referencesUniqueColumn="false"/&gt;
&lt;/changeSet&gt;
&lt;changeSet author="endy (generated)" id="1357786892853-15"&gt;
    &lt;addForeignKeyConstraint baseColumnNames="id_role" baseTableName="c_security_role_permission" baseTableSchemaName="merchant-simulator_development" constraintName="fk_role_permission_role" deferrable="false" initiallyDeferred="false" onDelete="NO ACTION" onUpdate="NO ACTION" referencedColumnNames="id" referencedTableName="c_security_role" referencedTableSchemaName="merchant-simulator_development" referencesUniqueColumn="false"/&gt;
&lt;/changeSet&gt;
&lt;changeSet author="endy (generated)" id="1357786892853-16"&gt;
    &lt;addForeignKeyConstraint baseColumnNames="id_role" baseTableName="c_security_user" baseTableSchemaName="merchant-simulator_development" constraintName="fk_user_role" deferrable="false" initiallyDeferred="false" onDelete="NO ACTION" onUpdate="NO ACTION" referencedColumnNames="id" referencedTableName="c_security_role" referencedTableSchemaName="merchant-simulator_development" referencesUniqueColumn="false"/&gt;
&lt;/changeSet&gt;
&lt;changeSet author="endy (generated)" id="1357786892853-17"&gt;
    &lt;createIndex indexName="name" tableName="c_application_config" unique="true"&gt;
        &lt;column name="name"/&gt;
    &lt;/createIndex&gt;
&lt;/changeSet&gt;
&lt;changeSet author="endy (generated)" id="1357786892853-18"&gt;
    &lt;createIndex indexName="unique_permission_value" tableName="c_security_permission" unique="true"&gt;
        &lt;column name="permission_value"/&gt;
    &lt;/createIndex&gt;
&lt;/changeSet&gt;
&lt;changeSet author="endy (generated)" id="1357786892853-19"&gt;
    &lt;createIndex indexName="unique_role_name" tableName="c_security_role" unique="true"&gt;
        &lt;column name="name"/&gt;
    &lt;/createIndex&gt;
&lt;/changeSet&gt;
&lt;changeSet author="endy (generated)" id="1357786892853-20"&gt;
    &lt;createIndex indexName="unique_user_username" tableName="c_security_user" unique="true"&gt;
        &lt;column name="username"/&gt;
    &lt;/createIndex&gt;
&lt;/changeSet&gt;
</code></pre>

<p></databaseChangeLog>
```</p>

<p>File di atas siap diedit dan disimpan di repository version control.
Biasanya, edit yang saya lakukan:</p>

<ul>
<li>menggabungkan semua <code>createTable</code> menjadi satu changeset</li>
<li>menggabungkan semua <code>addForeignKeyConstraint</code> dan <code>createIndex</code> menjadi satu changeset</li>
<li>menambahkan loader untuk file csv sebagai data awal</li>
<li>mengganti nama file</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Membuat Audit Log]]></title>
    <link href="http://software.endy.muhardin.com/java/membuat-audit-log/"/>
    <updated>2012-10-24T11:44:00+07:00</updated>
    <id>http://software.endy.muhardin.com/java/membuat-audit-log</id>
    <content type="html"><![CDATA[<h1>Membuat Audit Log dalam Aplikasi</h1>

<p>Dalam membuat aplikasi bisnis, kita sering diminta membuat audit log.</p>

<blockquote><p>Apa itu audit log?</p></blockquote>

<p>Audit log adalah catatan mengenai perubahan data dalam aplikasi.
Yang dicatat biasanya :</p>

<ul>
<li>kolom mana yang berubah</li>
<li>siapa yang mengubah</li>
<li>diubah dari apa menjadi apa</li>
<li>kapan dia berubah</li>
</ul>


<!--more-->


<p>Dengan menggunakan <a href="http://docs.jboss.org/hibernate/orm/4.1/devguide/en-US/html/ch15.html">Hibernate Envers</a>,
audit log ini bisa dibuat dengan mudah sekali.
Hibernate Envers adalah salah satu modul tambahan <a href="http://hibernate.org/">Hibernate</a> untuk keperluan ini.
Tentunya aplikasi kita harus menggunakan Hibernate supaya bisa memanfaatkan fitur ini.</p>

<h2>Konfigurasi Awal</h2>

<p>Konfigurasi dan setup awal sangat mudah, yaitu:</p>

<ol>
<li>Tambahkan JAR hibernate-envers ke dalam aplikasi</li>
<li>Tambahkan anotasi <code>@Audited</code> di class <code>@Entity</code> kita.</li>
</ol>


<p>Contoh perubahan ini bisa dilihat <a href="https://github.com/endymuhardin/belajar-auditlog/commit/05ca0c7c90b10cf64560d4cec933774aa91a8a81">di sini</a>.</p>

<h2>Audit Log Sederhana</h2>

<p>Entity class yang sudah ditambahi dengan annotation <code>@Audited</code> tampak seperti ini:</p>

<p>```java Kategori.java
@Entity @Audited
@Table(name="m_kategori")
public class Kategori {</p>

<pre><code>@Id @GeneratedValue(strategy= GenerationType.AUTO)
private Integer id;

@Column(nullable=false, unique=true)
private String kode;
private String nama;

// getter setter tidak ditampilkan
</code></pre>

<p>}
```</p>

<p>Pada awalnya, mapping di atas akan menghasilkan skema database seperti ini:</p>

<p><code>sql
CREATE TABLE `m_kategori` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `kode` varchar(255) NOT NULL,
  `nama` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `kode` (`kode`)
) ENGINE=InnoDB;
</code></p>

<p>Setelah ditambahi <code>@Audited</code>, Envers akan menambahkan satu tabel untuk keperluan audit log <code>m_kategori</code> dengan nama tabel ditambahi akhiran <code>_AUD</code> dan memiliki skema seperti ini:</p>

<p><code>sql
CREATE TABLE `m_kategori_AUD` (
  `id` int(11) NOT NULL,
  `REV` int(11) NOT NULL,
  `REVTYPE` tinyint(4) DEFAULT NULL,
  `kode` varchar(255) DEFAULT NULL,
  `nama` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`id`,`REV`),
  KEY `FK4263149C625F360` (`REV`),
  CONSTRAINT `FK4263149C625F360` FOREIGN KEY (`REV`) REFERENCES `REVINFO` (`id`)
) ENGINE=InnoDB;
</code></p>

<p>Kolom dalam tabelnya tidak jauh berbeda, dengan perbedaan sebagai berikut:</p>

<ul>
<li><p>tambahan kolom <code>REV</code> yang menunjukkan urutan perubahan.
  Nilai <code>REV</code> ini tidak berurut karena penambahannya (increment) sharing dengan semua tabel lain.
  Bisa saja <code>REV</code> <code>1</code> mencatat perubahan di <code>m_kategori</code> sedangkan <code>REV</code> <code>2</code> mencatat perubahan <code>m_produk</code>.</p></li>
<li><p>kolom <code>REVTYPE</code> yang menunjukkan jenis perubahan.
  Nilainya <code>0</code> untuk <strong>insert</strong> record baru, <code>1</code> untuk <strong>modifikasi</strong>, dan <code>2</code> untuk <strong>hapus</strong></p></li>
<li><p>kolom <code>id</code> tidak lagi menjadi primary key sendirian, tapi bersama dengan kolom <code>REV</code></p></li>
</ul>


<p>Kita juga lihat ada relasi ke tabel <code>REVINFO</code>. Skemanya sebagai berikut:</p>

<p><code>sql
CREATE TABLE `REVINFO` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `timestamp` bigint(20) NOT NULL
  PRIMARY KEY (`id`)
) ENGINE=InnoDB;
</code></p>

<p>Kolom <code>id</code> merupakan nilai yang bertambah terus (auto increment). Tabel ini akan diisi setiap kali ada revisi di tabel yang dipantau oleh Envers seperti tabel <code>m_kategori</code> kita di atas.
Tabel ini dishare oleh semua tabel audit log sehingga untuk satu tabel yang sama, nomer <code>REV</code> belum tentu berurutan. Bisa saja diselingi oleh nomer <code>REV</code> yang berkaitan dengan tabel lain. Kolom <code>timestamp</code> menunjukkan kapan revisi terjadi.</p>

<p>Untuk lebih memahami penggunaan tabel-tabel ini, mari kita lihat isi datanya.</p>

<p>Pertama, kita jalankan kode berikut dari aplikasi kita:</p>

<p>```java
@Test
public void testCrudKategori() {</p>

<pre><code>Kategori k = new Kategori();
k.setKode("K-999");
k.setNama("Kategori 999");

assertNull(k.getId());
belajarService.simpan(k);
assertNotNull(k.getId());

k.setKode("K-999-X");
k.setNama("Kategori 999-X");
belajarService.simpan(k);
Kategori kx = belajarService.cariKategoriById(k.getId());
assertEquals("K-999-X", kx.getKode());
assertEquals("Kategori 999-X", kx.getNama());

belajarService.hapus(k);
assertNull(belajarService.cariKategoriById(k.getId()));
</code></pre>

<p>}
```</p>

<p>Operasi di atas akan mengisi tabel audit sebagai berikut:</p>

<p><code>
select * from m_kategori_AUD order by id,REV,REVTYPE;
+-----+-----+---------+---------+-----------------------+
| id  | REV | REVTYPE | kode    | nama                  |
+-----+-----+---------+---------+-----------------------+
| 101 |   2 |       0 | K-999   | Kategori 999          |
| 101 |   3 |       1 | K-999-X | Kategori 999-X        |
| 101 |   4 |       2 | NULL    | NULL                  |
+-----+-----+---------+---------+-----------------------+
</code></p>

<p>Data dengan <code>REV</code> <code>1</code> dan <code>2</code> tidak ditampilkan karena mencatat record lain.
Dari isi tabel ini, kita bisa melihat bahwa terjadi tiga kali operasi pada record kategori dengan id 101, yaitu:</p>

<ol>
<li>Insert record baru. <code>REVTYPE</code> berisi <code>0</code>, artinya record baru. Kolom id, kode, dan nama berisi nilai yang pertama diisi.</li>
<li>Update kode dan nama. <code>REVTYPE</code> berisi <code>1</code>, artinya modifikasi. Kolom kode dan nama diisi dengan nilai setelah modifikasi</li>
<li>Delete record. <code>REVTYPE</code> berisi <code>2</code>, artinya hapus. Kolom kode dan nama diisi null karena datanya sudah tidak relevan (karena record dihapus).</li>
</ol>


<p>Berikut isi tabel <code>REVINFO</code></p>

<p><code>
select * from REVINFO;
+----+---------------+
| id | timestamp     |
+----+---------------+
|  2 | 1351521839648 |
|  3 | 1351521839718 |
|  4 | 1351521839801 |
+----+---------------+
</code></p>

<p>Karena hanya mencatat timestamp saja, maka tidak ada yang perlu dijelaskan mengenai isi tabel <code>REVINFO</code>.</p>

<h2>Penambahan informasi yang ingin dicatat</h2>

<p>Secara default, Hibernate Envers hanya mencatat data yang berubah dan kapan dia berubah.
Untuk menambahkan catatan tentang username, perlu ada sedikit coding seperti bisa dilihat <a href="https://github.com/endymuhardin/belajar-auditlog/commit/e910b6bc5ef33ee61f0137c8297b0f2ec4f502fe">di sini</a>. Kita harus :</p>

<ol>
<li>Extends <code>DefaultRevisionEntity</code> dan menambahkan kolom username</li>
<li>Membuat <code>RevisionListener</code> untuk mengisi kolom username tersebut</li>
</ol>


<p>Data username biasanya diambilkan dari user yang sedang login di aplikasi (dan dengan sendirinya dialah yang melakukan perubahan data).</p>

<p>Setelah dilakukan dua modifikasi di atas, skema REVINFO menjadi sebagai berikut:</p>

<p><code>sql
CREATE TABLE `REVINFO` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `timestamp` bigint(20) NOT NULL,
  `username` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB;
</code></p>

<p>Berikut yang sudah terisi data:</p>

<p><code>
select * from REVINFO;
+----+---------------+----------+
| id | timestamp     | username |
+----+---------------+----------+
|  1 | 1351521839220 | endy     |
|  2 | 1351521839648 | endy     |
|  3 | 1351521839718 | endy     |
|  4 | 1351521839801 | endy     |
|  5 | 1351521840174 | endy     |
|  6 | 1351521840571 | endy     |
|  7 | 1351521840959 | endy     |
|  8 | 1351521841351 | endy     |
+----+---------------+----------+
</code></p>

<h2>Penyesuaian Lain</h2>

<p>Selain penambahan kolom yang ingin dicatat, biasanya kita juga ingin melakukan penyesuaian lain seperti:</p>

<ul>
<li>akhiran di nama tabel audit (<code>_AUD</code>)</li>
<li>nama kolom nomer revisi (<code>REV</code>)</li>
<li>nama kolom jenis revisi (<code>REVTYPE</code>)</li>
<li>dan sebagainya</li>
</ul>


<p>Keterangan apa saja yang bisa diubah dan cara mengubahnya dapat dilihat di <a href="http://docs.jboss.org/hibernate/orm/4.1/devguide/en-US/html/ch15.html#d5e3937">dokumentasi konfigurasi Envers</a>.</p>

<p>Contoh kode yang lengkap bisa diambil di <a href="https://github.com/endymuhardin/belajar-auditlog">repository saya di Github</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Konsep Dasar Log4j]]></title>
    <link href="http://software.endy.muhardin.com/java/konsep-dasar-log4/"/>
    <updated>2012-07-30T20:59:00+07:00</updated>
    <id>http://software.endy.muhardin.com/java/konsep-dasar-log4</id>
    <content type="html"><![CDATA[<p>Walaupun sudah dibuatkan <a href="http://endy.artivisi.com/blog/java/menggunakan-log4j">minibook</a>, tapi ternyata ada juga beberapa orang yang tidak paham bagaimana cara enable/disable log message di aplikasi Java. Oleh karena itu, baiklah saya jelaskan lagi secara lebih singkat.</p>

<!--more-->


<p>Ada beberapa komponen penting dalam aplikasi logging :</p>

<ul>
<li><p>logger : ini adalah yang kita gunakan di aplikasi untuk mengeluarkan pesan.
tadinya System.out.println("Coba");
diganti menjadi logger.info("Coba");</p></li>
<li><p>appender : komponen yang bertugas menampilkan log message
misalnya : console appender : menampilkan ke System.out
File appender : menulis log ke file
Rolling file appender : menulis ke file, lalu dirolling berdasarkan kriteria tertentu (size atau time)
misalnya, setelah mencapai 1 MB, tulis ke file berbeda, atau tiap 1 jam ganti file</p></li>
<li><p>category : ini adalah sumber log message, yaitu package atau realm.
<strong>biasanya</strong> category == package
Ini digunakan untuk memfilter log mana yang akan ditampilkan ke appender mana</p></li>
</ul>


<p>Selain 3 komponen itu, ada terminologi yang namanya level.
Contoh level : error, warn, info, debug, trace
Level ini berlaku bertingkat, jadi kalau kita bilang info, artinya info, warn, error.
Kalau kita bilang debug, maka hasilnya debug, info, warn, error.</p>

<p>Log message ditampilkan atau tidak, tergantung category dan level.</p>

<p>Contoh kasus :
Saya membuat aplikasi, berisi package com.artivisi.belajar.logging.
Isinya ada 2 class, Coba dan Halo.</p>

<p>Aplikasi saya ini menggunakan framework Spring, yang mana berisi package org.springframework, yang berisi banyak sub package, seperti org.springframework.core, org.springframework.jdbc, dsb.</p>

<p>Untuk source code yang saya tulis sendiri (Coba dan Halo), saya ingin menampilkan level debug, karena masih fase development. Nantinya kalau sudah production, cukup level warn saja yang ditampilkan.
Sedangkan untuk library Spring Framework, cukup level error saja yang ditampilkan.</p>

<p>Semua log message ditampilkan ke terminal, supaya mudah diamati.</p>

<p>Contoh kasus di atas, bila kita menggunakan log4j akan dikonfigurasi sebagai berikut :</p>

<p><div><script src='https://gist.github.com/3205393.js'></script>
<noscript><pre><code># by default, levelnya adalah INFO, tampilkan ke System.out
log4j.rootLogger=INFO,Konsole 

# untuk package com.artivisi, tampilkan level DEBUG ke System.out
log4j.logger.com.artivisi=DEBUG,Konsole

# untuk spring, error saja yang ditampilkan
log4j.logger.org.springframework=ERROR,Konsole

# Appender Konsole adalah System.out
log4j.appender.Konsole=org.apache.log4j.ConsoleAppender 
log4j.appender.Konsole.layout=org.apache.log4j.PatternLayout 
# Format tanggal menurut ISO­8601 : %d 
log4j.appender.Konsole.layout.ConversionPattern=%d [%t] %­5p %c ­ %m%n
</code></pre></noscript></div>
</p>

<p>Konfigurasi di atas harus dibuat dengan nama log4j.properties, dan diletakkan di dalam classpath. Kalau namanya tidak sama atau lokasinya salah, maka tidak akan dibaca oleh Log4J.</p>
]]></content>
  </entry>
  
</feed>
