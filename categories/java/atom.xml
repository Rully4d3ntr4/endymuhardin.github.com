<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: java | Living life and make it better]]></title>
  <link href="http://software.endy.muhardin.com/categories/java/atom.xml" rel="self"/>
  <link href="http://software.endy.muhardin.com/"/>
  <updated>2013-05-29T07:36:39+07:00</updated>
  <id>http://software.endy.muhardin.com/</id>
  <author>
    <name><![CDATA[Endy Muhardin]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Struktur Aplikasi Java dengan Spring dan Maven]]></title>
    <link href="http://software.endy.muhardin.com/java/struktur-aplikasi-java-dengan-spring-dan-maven/"/>
    <updated>2013-05-28T15:06:00+07:00</updated>
    <id>http://software.endy.muhardin.com/java/struktur-aplikasi-java-dengan-spring-dan-maven</id>
    <content type="html"><![CDATA[<p>Pada <a href="http://software.endy.muhardin.com/java/konfigurasi-koneksi-database-dengan-spring/">bagian sebelumnya</a> kita telah membahas konfigurasi awal
dan studi kasus yang akan digunakan untuk menunjukkan fitur Spring JDBC.</p>

<p>Di artikel bagian kedua ini, kita akan membahas tentang kerangka aplikasi yang akan dibuat.
Sebelum membuat implementasi detail, sangat penting kita buat dulu kerangkanya supaya jelas
apa saja bagian-bagian dalam aplikasi dan bagaimana mereka saling terhubung.</p>

<p>Artikel ini merupakan bagian kedua dari rangkaian artikel Spring JDBC, yaitu</p>

<ol>
<li><a href="http://software.endy.muhardin.com/java/konfigurasi-koneksi-database-dengan-spring/">Konfigurasi koneksi database</a></li>
<li><a href="http://software.endy.muhardin.com/java/struktur-aplikasi-java-dengan-spring-dan-maven/">Struktur Aplikasi</a></li>
<li>Insert, update, dan delete data</li>
<li>Mengambil data (query)</li>
<li>Melakukan pengetesan</li>
</ol>


<!--more-->


<h2>Daftar class yang akan dibuat</h2>

<p>Class yang akan dibuat kita bagi menjadi empat fungsi utama, yaitu:</p>

<ul>
<li>domain object : class yang mewakili struktur data dalam aplikasi kita</li>
<li>interface business service : class yang mendefinisikan daftar fitur-fitur dalam aplikasi</li>
<li>implementasi business service : implementasi dari interface business service. Kalau di interface hanya ada nama method, argumen, dan tipe data kembalian (return value), di sini sudah ada implementasi konkritnya, yaitu bagaimana query database, logika perhitungan, dan sebagainya.</li>
<li>automated test : memeriksa apakah method kita berjalan benar itu melelahkan. Jadi kita buatkan kode program untuk mengetesnya, sehingga tes yang sama bisa dijalankan berulang-ulang tanpa membuat kita lelah. Lebih lanjut tentang automated test bisa dibaca di <a href="http://software.endy.muhardin.com/java/ruthless-testing-1/">artikel lain yang membahas masalah ini</a>.</li>
</ul>


<h3>Domain Object</h3>

<p>Sesuai dengan skema database, kita akan membuat tiga class, yaitu:</p>

<ul>
<li>Produk</li>
<li>Penjualan</li>
<li>PenjualanDetail</li>
</ul>


<p>Buat yang sudah pernah coding JDBC biasanya akan bertanya,</p>

<p><blockquote><p>Kenapa repot-repot membuat domain class, kemudian harus konversi bolak balik?<br/>Kan bisa saja kita kirim <code>ResultSet</code> ke tampilan, ataupun insert langsung dari array ke <code>PreparedStatement</code>.</p></blockquote></p>

<p>Pertanyaan ini biasanya muncul dari programmer PHP yang terbiasa langsung menampilkan kembalian <code>mysql_fetch_array</code> dalam looping tabel.</p>

<p>Ada beberapa alasan:</p>

<ol>
<li><p>Sebenarnya bisa saja kita buat aplikasi dengan menggunakan tipe data yang disediakan Java seperti Integer, String, Map, List, dan lainnya. Tapi akibatnya kode program kita menjadi sulit dimengerti. Coba bandingkan, lebih mudah dimengerti <code>public void simpan(Produk p)</code> atau <code>public void simpan(Map p)</code>? Dengan membuat tipe data sesuai istilah yang digunakan di domain kita, maka kode program akan lebih mudah dipahami.</p></li>
<li><p>Java merupakan bahasa yang <a href="http://en.wikipedia.org/wiki/Strong_and_weak_typing">strongly-typed</a>, dia memeriksa tipe data/class dari tiap variabel. Pada ilustrasi di atas, method <code>public void simpan(Map p)</code> akan menerima apapun data yang kita masukkan ke dalam variabel <code>p</code>. Kalau ada kesalahan dalam nama variabel (misalnya nama ditulis name), baru akan terdeteksi pada waktu aplikasi dijalankan. Berbeda dengan <code>public void simpan(Produk p)</code> yang akan langsung menimbulkan pesan error apabila kita isi dengan tipe data selain <code>Produk</code>. Bug yang ditemukan pada waktu coding (compile-time) akan jauh lebih cepat diperbaiki daripada bug yang baru ditemukan pada waktu aplikasi dijalankan (runtime). Programmer PHP ada benarnya juga. Di bahasa PHP memang domain class ini tidak diperlukan, karena PHP tidak ada pemeriksaan compile-time. Tapi karena kita menggunakan Java, ada baiknya kita manfaatkan pemeriksaan compile-time ini.</p></li>
<li><p>Memisahkan antara layer database dan layer antarmuka. Apabila ada perubahan skema database, asalkan fitur di tampilan tidak berubah, kita cukup mengubah mapping domain object dan skema database. Tidak perlu mengubah kode program di layer antarmuka.</p></li>
<li><p>Pustaka siap pakai untuk validasi. Di Java, ada yang namanya <a href="http://jcp.org/en/jsr/detail?id=303">JSR-303</a>, yaitu suatu pustaka yang berguna untuk validasi. Dengan <a href="http://www.mkyong.com/spring-mvc/spring-3-mvc-and-jsr303-valid-example/">menggunakan JSR-303</a> ini kita tidak perlu lagi melakukan pengecekan <code>if(produk.getKode() == null)</code>. Cukup kita gunakan deklarasi <code>@NotNull private String kode;</code> dalam class <code>Produk</code></p></li>
</ol>


<h3>Interface Business Service</h3>

<p>Interface di Java artinya class yang methodnya abstrak semua. Lebih detail tentang method abstrak bisa dibaca di <a href="http://software.endy.muhardin.com/java/interface-abstract/">artikel ini</a>. Ada beberapa alasan kenapa kita harus memisahkan interface dan implementasinya, antara lain:</p>

<ul>
<li><p>pada waktu <a href="http://software.endy.muhardin.com/java/remoting-dengan-spring/">membuat aplikasi client-server</a>, kita cukup memberikan domain object dan interface ini kepada programmer aplikasi client. Sedangkan implementasinya (yang berisi kode program akses database) tetap di server. Ini akan meringankan ukuran aplikasi client, karena tidak perlu menyertakan implementasi (beserta library pendukungnya yang biasanya besar) yang tidak dia gunakan.</p></li>
<li><p>kita bebas mengubah strategi implementasi (misalnya ganti database dari MySQL menjadi PostgreSQL) tanpa perlu mengganggu aplikasi client</p></li>
<li><p>fitur declarative transaction yang dimiliki Spring akan lebih optimal bekerja bila kita memisahkan interface dan implementasi.</p></li>
</ul>


<p>Interface ini cukup satu class saja, yaitu <code>AplikasiPenjualanService</code>.</p>

<h3>Implementasi Business Service</h3>

<p>Ini merupakan implementasi dari interface <code>AplikasiPenjualanService</code>. Pada prakteknya, ada dua variasi yang biasa saya gunakan dalam membuat implementasi, yaitu:</p>

<ul>
<li>cukup membuat class implementasi service saja</li>
<li>membuat class implementasi service dan juga class data access object (DAO)</li>
</ul>


<p>Kapan memilih variasi yang mana?</p>

<ul>
<li>Bila menggunakan framework Spring Data JPA, kita harus pakai DAO karena frameworknya minta seperti itu</li>
<li>Selain Spring Data JPA, bebas mau pakai yang mana. Pilih saja yang lebih rapi dan mudah maintenance. Untuk aplikasi kecil, class implementasi service saja sudah cukup. Kalau aplikasinya besar, akan lebih mudah membaca 10 class DAO yang masing-masingnya terdiri dari 100 baris kode daripada 1000 baris dalam satu class implementasi service. Walaupun demikian, tidak ada pertimbangan teknis yang signifikan (seperti isu performance dan lainnya) antara pakai DAO atau tidak.</li>
</ul>


<h3>Automated Test</h3>

<p>Ini adalah kode program yang fungsinya mengetes kode program lainnya, dalam hal ini class implementasi dan class DAO. Konsep dasar tentang automated testing dibahas di <a href="http://software.endy.muhardin.com/java/ruthless-testing-1/">artikel ini</a>. Sedangkan untuk pengetesan database dibahas <a href="http://software.endy.muhardin.com/java/ruthless-testing-4/">di sini</a>.</p>

<p>Pada contoh aplikasi ini, kita menghadapi tantangan khusus, yaitu bagaimana caranya menggunakan test case yang sama untuk konfigurasi berbeda. Nantinya aplikasi ini akan dikembangkan untuk mendemonstrasikan akses database menggunakan framework lain seperti Hibernate, Spring Data JPA, dan JDBC polos tanpa framework. Logika pengetesan akan sama persis, yaitu:</p>

<ul>
<li>test insert</li>
<li>test update</li>
<li>test delete</li>
<li>test cari berdasarkan id</li>
<li>test ambil semua data dari tabel tertentu</li>
<li>test cari data dengan kriteria tertentu</li>
</ul>


<p>Tabel database yang diakses sama, sample data sama, bahkan nama method yang dijalankan juga sama. Bedanya hanyalah class implementasi mana yang digunakan dan konfigurasi mana yang dipakai.</p>

<p>Untuk itu, kita akan menggunakan teknik khusus yang disebut <code>abstract junit test case</code>. Secara garis besar, langkahnya seperti ini:</p>

<ol>
<li>Buat semua method test di superclass. Superclass ini memiliki abstract method, sehingga dengan sendirinya dia juga abstract.</li>
<li>Untuk mendapatkan class implementasi dan melakukan inisialisasi konfigurasi, gunakan abstract method</li>
<li>Buat subclass untuk masing-masing implementasi (Spring JDBC, Hibernate, dst) yang hanya berisi implementasi dari abstract method tersebut.</li>
</ol>


<p>Agar lebih jelas, silahkan lihat <a href="https://github.com/endymuhardin/belajar-akses-database-java/blob/spring-jdbc/src/test/java/com/muhardin/endy/training/java/aksesdb/service/ProdukServiceTest.java">superclassnya</a> dan <a href="https://github.com/endymuhardin/belajar-akses-database-java/blob/spring-jdbc/src/test/java/com/muhardin/endy/training/java/aksesdb/service/springjdbc/ProdukServiceSpringJdbcTest.java">subclass untuk Spring JDBC</a>.</p>

<h2>Struktur folder</h2>

<p>Sekian banyak class, bagaimana penempatannya? Silahkan lihat struktur folder berikut:</p>

<p><img src="/images/uploads/2013/05/struktur-aplikasi-spring-maven/01-struktur-folder-top-level.png" title="Top Level Folder" ></p>

<p>Tidak ada yang istimewa dari struktur di atas, cuma struktur folder standar Maven. Mari kita lihat source code aplikasi.</p>

<p><img src="/images/uploads/2013/05/struktur-aplikasi-spring-maven/02-struktur-folder-main-java.png" title="Source Folder Java" ></p>

<p>Di sini kita bisa lihat class sudah diatur ke dalam package berbeda sesuai fungsinya, yaitu domain, service, dao. Untuk implementasi service dengan Spring JDBC kita buatkan package tersendiri. Selanjutnya kita lihat lokasi file konfigurasi.</p>

<p><img src="/images/uploads/2013/05/struktur-aplikasi-spring-maven/03-struktur-folder-main-resources.png" title="Source Folder Konfigurasi" ></p>

<p>File konfigurasi ditaruh dalam package. Sebetulnya ditaruh di top level juga boleh, ini hanya sekedar kebiasaan saja.</p>

<p><img src="/images/uploads/2013/05/struktur-aplikasi-spring-maven/04-struktur-folder-test.png" title="Source Test Folder" ></p>

<p>Lokasi penempatan test class bisa dilihat di atas. Abstract class yang saya ceritakan di atas terlihat di package <code>com.muhardin.endy.training.java.aksesdb.service</code>, sedangkan implementasi konfigurasinya ada di subpackage <code>springjdbc</code> di bawahnya.</p>

<p>Setelah kita melihat penempatan file dan folder, mari kita lihat kerangka kode program di masing-masing class/file. Supaya bisa mendapatkan <em>big-picture</em>, kita akan lihat kerangka class dan method saja. Implementasinya menyusul pada bagian selanjutnya.</p>

<h1>Domain Object</h1>

<h2>Class Produk</h2>

<p>Class ini merupakan padanan tabel m_produk di database.
Dia memiliki beberapa property sesuai dengan kolom di database.
Berikut penjelasannya</p>

<table>
<thead>
<tr>
<th>Nama Property </th>
<th> Nama Kolom Database </th>
<th> Tipe Data Java </th>
<th> Tipe Data MySQL</th>
</tr>
</thead>
<tbody>
<tr>
<td>id            </td>
<td> id                  </td>
<td> Integer        </td>
<td> integer</td>
</tr>
<tr>
<td>kode          </td>
<td> kode                </td>
<td> String         </td>
<td> varchar</td>
</tr>
<tr>
<td>nama          </td>
<td> nama                </td>
<td> String         </td>
<td> varchar</td>
</tr>
<tr>
<td>harga         </td>
<td> harga               </td>
<td> BigDecimal     </td>
<td> decimal(19,2)</td>
</tr>
</tbody>
</table>


<p>Berikut kode program untuk class Produk.</p>

<p>```java
package com.muhardin.endy.training.java.aksesdb.domain;</p>

<p>import java.math.BigDecimal;</p>

<p>public class Produk {</p>

<pre><code>private Integer id;
private String kode;
private String nama;
private BigDecimal harga;

// getter dan setter generate dari IDE
</code></pre>

<p>}
```</p>

<h2>Class Penjualan</h2>

<p>Mapping Java ke SQL</p>

<table>
<thead>
<tr>
<th>Nama Property  </th>
<th> Nama Kolom Database </th>
<th> Tipe Data Java </th>
<th> Tipe Data MySQL</th>
</tr>
</thead>
<tbody>
<tr>
<td>id             </td>
<td> id                  </td>
<td> Integer        </td>
<td> integer</td>
</tr>
<tr>
<td>waktuTransaksi </td>
<td> waktu_transaksi     </td>
<td> Date           </td>
<td> datetime</td>
</tr>
</tbody>
</table>


<p>Kode program class Penjualan</p>

<p>```java
package com.muhardin.endy.training.java.aksesdb.domain;</p>

<p>// import generate dari IDE</p>

<p>public class Penjualan {</p>

<pre><code>private Integer id;
private Date waktuTransaksi;
private List&lt;PenjualanDetail&gt; daftarPenjualanDetail 
    = new ArrayList&lt;PenjualanDetail&gt;();

// getter dan setter generate dari IDE
</code></pre>

<p>}
```</p>

<h2>Class Penjualan Detail</h2>

<p>Mapping Java ke SQL</p>

<table>
<thead>
<tr>
<th>Nama Property  </th>
<th> Nama Kolom Database </th>
<th> Tipe Data Java </th>
<th> Tipe Data MySQL</th>
</tr>
</thead>
<tbody>
<tr>
<td>id             </td>
<td> id                  </td>
<td> Integer        </td>
<td> integer</td>
</tr>
<tr>
<td>penjualan      </td>
<td> id_penjualan        </td>
<td> Penjualan      </td>
<td> integer foreign key</td>
</tr>
<tr>
<td>produk         </td>
<td> id_produk           </td>
<td> Produk         </td>
<td> integer foreign key</td>
</tr>
<tr>
<td>jumlah         </td>
<td> jumlah              </td>
<td> Integer        </td>
<td> integer</td>
</tr>
<tr>
<td>harga          </td>
<td> harga               </td>
<td> BigDecimal     </td>
<td> decimal(19,2)</td>
</tr>
</tbody>
</table>


<p>Kode program class PenjualanDetail</p>

<p>```java
package com.muhardin.endy.training.java.aksesdb.domain;</p>

<p>import java.math.BigDecimal;</p>

<p>public class PenjualanDetail {</p>

<pre><code>private Integer id;
private Penjualan penjualan;
private Produk produk;
private BigDecimal harga;
private Integer jumlah;

// getter dan setter generate dari IDE
</code></pre>

<p>}
```</p>

<p>Yang perlu diperhatikan di sini adalah perbedaan cara perlakuan relasi antara Java dan database.
Di Java, kita perlu mendefinisikan relasi di dua tempat, yaitu variabel <code>daftarPenjualanDetail</code> di class <code>Penjualan</code>
dan variabel <code>penjualan</code> di class <code>PenjualanDetail</code>. Sedangkan di database, relasi ini cukup didefinisikan melalui foreign key
<code>id_penjualan</code> di tabel <code>t_penjualan_detail</code>.</p>

<p>Perbedaan lain, di database relasi ini cukup diwakili satu nilai saja, yaitu nilai foreign key.
Sedangkan di Java diwakili satu class penuh (<code>Produk</code> atau <code>Penjualan</code>) yang di dalamnya memuat banyak nilai.</p>

<p>Untuk menjembatani perbedaan ini, kita perlu membuat mapper untuk mengubah data dari database menjadi object Java dan sebaliknya. Contoh kode program untuk mapper ini akan dibahas pada bagian selanjutnya.</p>

<h1>Interface Business Service</h1>

<p>Ini adalah daftar fitur yang ada di aplikasi, didefinisikan berupa class/interface dan method.</p>

<p>```java
package com.muhardin.endy.training.java.aksesdb.service;</p>

<p>// import generate dari IDE</p>

<p>public interface PenjualanService {</p>

<pre><code>// service berkaitan dengan produk
void simpan(Produk p);
Produk cariProdukById(Integer id);
Produk cariProdukByKode(String kode);
Long hitungSemuaProduk();
List&lt;Produk&gt; cariSemuaProduk(Integer halaman, Integer baris);
Long hitungProdukByNama(String nama);
List&lt;Produk&gt; cariProdukByNama(String nama, Integer halaman, Integer baris);

// service yang berkaitan dengan transaksi
void simpan(Penjualan p);
Penjualan cariPenjualanById(Integer id);
Long hitungPenjualanByPeriode(Date mulai, Date sampai);
List&lt;Penjualan&gt; cariPenjualanByPeriode(Date mulai, Date sampai, Integer halaman, Integer baris);
Long hitungPenjualanDetailByProdukDanPeriode(Produk p, Date mulai, Date sampai);
List&lt;PenjualanDetail&gt; cariPenjualanDetailByProdukDanPeriode(Produk p, Date mulai, Date sampai, Integer halaman, Integer baris);
</code></pre>

<p>}
```</p>

<h1>Implementasi Business Service</h1>

<p>Implementasi dari interface di atas kita bagi menjadi dua kategori, yaitu class implementasi service yang nantinya akan memanggil class DAO. Pertimbangan dan alasan mengapa begini sudah dijelaskan di atas.</p>

<h2>Class ServiceSpringJdbc</h2>

<p>Class ini sebetulnya hanya memanggil class DAO saja, jadi baiklah kita tampilkan seluruh isinya di sini.</p>

<p>```java
package com.muhardin.endy.training.java.aksesdb.service.springjdbc;</p>

<p>// import statement generate dari IDE</p>

<p>@Service @Transactional
public class PenjualanServiceSpringJdbc implements PenjualanService{</p>

<pre><code>@Autowired private ProdukDao produkDao;
@Autowired private PenjualanDao penjualanDao;
@Autowired private PenjualanDetailDao penjualanDetailDao;

@Override
public void simpan(Produk p) {
    produkDao.simpan(p);
}

@Override
public Produk cariProdukById(Integer id) {
    return produkDao.cariById(id);
}

@Override
public Produk cariProdukByKode(String kode) {
    return produkDao.cariByKode(kode);
}

@Override
public Long hitungSemuaProduk() {
    return produkDao.hitungSemua();
}

@Override
public List&lt;Produk&gt; cariSemuaProduk(Integer halaman, Integer baris) {
    return produkDao.cariSemua(halaman, baris);
}

@Override
public Long hitungProdukByNama(String nama) {
    return produkDao.hitungByNama(nama);
}

@Override
public List&lt;Produk&gt; cariProdukByNama(String nama, Integer halaman, Integer baris) {
    return produkDao.cariByNama(nama, halaman, baris);
}

@Override
public void simpan(Penjualan p) {
    penjualanDao.simpan(p);
}

@Override
public Penjualan cariPenjualanById(Integer id) {
    return penjualanDao.cariById(id);
}

@Override
public Long hitungPenjualanByPeriode(Date mulai, Date sampai) {
    return penjualanDao.hitungByPeriode(mulai, sampai);
}

@Override
public List&lt;Penjualan&gt; cariPenjualanByPeriode(Date mulai, Date sampai, 
        Integer halaman, Integer baris) {
    return penjualanDao.cariByPeriode(mulai, sampai, halaman, baris);
}

@Override
public Long hitungPenjualanDetailByProdukDanPeriode(Produk p, 
        Date mulai, Date sampai) {
    return penjualanDetailDao.hitungByProdukDanPeriode(p, mulai, sampai);
}

@Override
public List&lt;PenjualanDetail&gt; cariPenjualanDetailByProdukDanPeriode(Produk p, 
        Date mulai, Date sampai, Integer halaman, Integer baris) {
    return penjualanDetailDao.cariByProdukDanPeriode(p, mulai, sampai, halaman, baris);
}
</code></pre>

<p>}
```</p>

<h2>Class DAO</h2>

<p>Class DAO akan kita bahas secara mendetail di bagian selanjutnya. Pada kesempatan ini kita hanya tampilkan deklarasi class dan method saja supaya jelas mana method yang dipanggil dari implementasi service di atas.</p>

<h3>ProdukDAO</h3>

<p>```java
package com.muhardin.endy.training.java.aksesdb.dao.springjdbc;</p>

<p>// import generate dari IDE</p>

<p>@Repository
public class ProdukDao {</p>

<pre><code>public void simpan(Produk p) {}

public Produk cariById(Integer id) {}

public Produk cariByKode(String kode) {}

public Long hitungSemua() {}

public List&lt;Produk&gt; cariSemua(Integer halaman, Integer baris) {}

public Long hitungByNama(String nama) {}

public List&lt;Produk&gt; cariByNama(String nama, Integer halaman, Integer baris) {}

private class ResultSetJadiProduk implements RowMapper&lt;Produk&gt; {
    @Override
    public Produk mapRow(ResultSet rs, int i) throws SQLException {}
}
</code></pre>

<p>}
```</p>

<h3>PenjualanDao</h3>

<p>```java
package com.muhardin.endy.training.java.aksesdb.dao.springjdbc;</p>

<p>// import generate dari IDE</p>

<p>@Repository
public class PenjualanDao {</p>

<pre><code>public void simpan(Penjualan p) {}

public Penjualan cariById(Integer id) {}

public Long hitungByPeriode(Date mulai, Date sampai) {}

public List&lt;Penjualan&gt; cariByPeriode(Date mulai, Date sampai, Integer halaman, Integer baris) {}


private class ResultSetJadiPenjualan implements RowMapper&lt;Penjualan&gt; {
    @Override
    public Penjualan mapRow(ResultSet rs, int i) throws SQLException {}
}
</code></pre>

<p>}
```</p>

<h3>PenjualanDetailDao</h3>

<p>```java
package com.muhardin.endy.training.java.aksesdb.dao.springjdbc;</p>

<p>// import generate dari IDE</p>

<p>@Repository
public class PenjualanDetailDao {</p>

<pre><code>public void simpan(final PenjualanDetail p) {}

public List&lt;PenjualanDetail&gt; cariByPenjualan(Penjualan p) {}

public Long hitungByProdukDanPeriode(Produk p, Date mulai, Date sampai) {}

public List&lt;PenjualanDetail&gt; cariByProdukDanPeriode(Produk p, Date mulai, Date sampai, Integer halaman, Integer baris) {}


private class ResultSetJadiPenjualanDetail implements RowMapper&lt;PenjualanDetail&gt; {
    @Override
    public PenjualanDetail mapRow(ResultSet rs, int i) throws SQLException {}
}
</code></pre>

<p>}
```</p>

<h1>Automated Test</h1>

<p>Seperti dijelaskan di atas, automated test kita bagi menjadi dua kategori, yaitu abstract class yang menampung semua logika pengetesan, dan concrete class yang menyediakan konfigurasi.</p>

<h2>Abstract Base Class</h2>

<h3>ProdukServiceTest</h3>

<p>```java
package com.muhardin.endy.training.java.aksesdb.service;</p>

<p>// import generate dari IDE</p>

<p>public abstract class ProdukServiceTest {</p>

<pre><code>public abstract PenjualanService getPenjualanService();
public abstract DataSource getDataSource();

@Before
public void bersihkanDataTest() throws Exception {}

@Test
public void testSimpanProduk() {}

@Test
public void testCariProdukById() {}

@Test
public void testCariProdukByKode() {}

@Test
public void testHitungSemuaProduk() {}

@Test
public void testCariSemuaProduk() {}

@Test
public void testHitungProdukByNama() {}

@Test
public void testCariProdukByNama() {}
</code></pre>

<p>}
```</p>

<h3>PenjualanServiceTest</h3>

<p>```java
package com.muhardin.endy.training.java.aksesdb.service;</p>

<p>// import generate dari IDE</p>

<p>public abstract class PenjualanServiceTest {</p>

<pre><code>public abstract PenjualanService getPenjualanService();
public abstract DataSource getDataSource();

@Before
public void bersihkanDataTest() throws Exception {}

@Test
public void testSimpanPenjualan() throws Exception {}

@Test
public void testCariPenjualanById(){}

@Test
public void testHitungPenjualanByPeriode(){}

@Test
public void testCariPenjualanByPeriode(){}

@Test
public void testHitungPenjualanDetailByProdukDanPeriode(){}

@Test
public void testCariPenjualanDetailByProdukDanPeriode(){}
</code></pre>

<p>}
```</p>

<p>Seperti kita lihat di atas, kedua class tersebut memiliki dua abstract method, yaitu:</p>

<ul>
<li><code>public abstract PenjualanService getPenjualanService()</code></li>
<li><code>public abstract DataSource getDataSource();</code></li>
</ul>


<p>Kedua object <code>PenjualanService</code> dan <code>DataSource</code> didapatkan dari konfigurasi Spring.
Konfigurasi Spring dibuat berdasarkan teknologi yang digunakan.
Konfigurasi Spring JDBC berbeda dengan konfigurasi Hibernate ataupun Spring Data JPA.</p>

<p>Dengan teknik ini, bila di kemudian hari kita membuat implementasi dengan Hibernate atau Spring Data JPA,
kita tidak perlu lagi copy-paste test class, cukup buat subclass yang menyediakan kedua object tersebut.</p>

<p>Berikut adalah subclassnya</p>

<h2>Implementasi Test Business Service</h2>

<p>Karena hanya beberapa baris dan tidak butuh banyak penjelasan, kita tampilkan di sini full source code, bukan hanya kerangkanya saja.</p>

<h3>ProdukServiceSpringJdbcTest</h3>

<p>```java
package com.muhardin.endy.training.java.aksesdb.service.springjdbc;</p>

<p>// import generate dari IDE</p>

<p>@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration("classpath*:com/muhardin/**/spring-jdbc-ctx.xml")
public class ProdukServiceSpringJdbcTest extends ProdukServiceTest {</p>

<pre><code>@Autowired private DataSource dataSource;
@Autowired private PenjualanService penjualanService;

@Override
public PenjualanService getPenjualanService() {
    return penjualanService;
}

@Override
public DataSource getDataSource() {
    return dataSource;
}
</code></pre>

<p>}
```</p>

<h3>PenjualanServiceSpringJdbcTest</h3>

<p>```java
package com.muhardin.endy.training.java.aksesdb.service.springjdbc;</p>

<p>// import generate dari IDE</p>

<p>@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration("classpath*:com/muhardin/**/spring-jdbc-ctx.xml")
public class PenjualanServiceSpringJdbcTest extends PenjualanServiceTest {</p>

<pre><code>@Autowired private DataSource dataSource;
@Autowired private PenjualanService penjualanService;

@Override
public PenjualanService getPenjualanService() {
    return penjualanService;
}

@Override
public DataSource getDataSource() {
    return dataSource;
}
</code></pre>

<p>}
```</p>

<p>Seperti kita lihat di atas, <code>dataSource</code> dan <code>penjualanService</code> disediakan melalui Dependency Injection.</p>

<p>Cara kerjanya sebagai berikut:</p>

<ol>
<li>Kita jalankan JUnit melalui IDE atau Maven. IDE atau Maven akan membaca semua file dalam folder <code>src/test/java</code> dan memproses semua class yang namanya berakhiran <code>Test</code> seperti <code>PenjualanServiceSpringJdbcTest</code>. IDE/Maven juga memproses <code>PenjualanServiceTest</code>, tapi karena classnya abstract maka tidak diproses lebih lanjut.</li>
<li>JUnit melihat annotation <code>@RunWith</code>, jadi dia tidak menjalankan sendiri melainkan menyuruh <code>SpringJUnit4ClassRunner</code> untuk menjalankan test</li>
<li><code>SpringJUnit4ClassRunner</code> membaca annotation <code>@ContextConfiguration</code>, lalu menggunakan nilai di dalamnya untuk melakukan inisialisasi <code>ApplicationContext</code>, kemudian mengisi variabel yang ditandai dengan <code>@Autowired</code></li>
<li>Karena <code>PenjualanServiceSpringJdbcTest</code> merupakan subclass dari <code>PenjualanServiceTest</code>, maka dia akan mewarisi semua method <code>@Test</code> yang dimiliki <code>PenjualanServiceTest</code>. Method <code>@Test</code> ini akan dijalankan oleh IDE/Maven.</li>
<li>Pada waktu method <code>@Test</code> dijalankan, bila perlu object <code>PenjualanService</code>, maka akan didapat dengan cara memanggil method <code>getPenjualanService</code>. Karena methodnya sudah dibuatkan implementasinya (tidak abstract lagi) dan sudah ada isinya, maka method <code>@Test</code> dapat bekerja dengan baik.</li>
</ol>


<p>Demikianlah bagian kedua dari tutorial mengakses database menggunakan Spring JDBC. Pada bagian ini kita sudah melihat bagaimana cara pengaturan file/folder dan interaksi antar class/method. Di bagian selanjutnya kita akan lihat bagaimana cara menjalankan perintah SQL.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Konfigurasi Koneksi Database dengan Spring]]></title>
    <link href="http://software.endy.muhardin.com/java/konfigurasi-koneksi-database-dengan-spring/"/>
    <updated>2013-05-27T17:02:00+07:00</updated>
    <id>http://software.endy.muhardin.com/java/konfigurasi-koneksi-database-dengan-spring</id>
    <content type="html"><![CDATA[<p>Di Java, ada banyak cara untuk mengakses database, diantaranya:</p>

<ul>
<li><a href="http://docs.oracle.com/javase/tutorial/jdbc/">JDBC polos tanpa framework apapun</a></li>
<li><a href="http://static.springsource.org/spring/docs/3.2.x/spring-framework-reference/html/jdbc.html">JDBC dengan Spring (Spring JDBC)</a></li>
<li>JDBC dengan <a href="http://blog.mybatis.org/">iBatis/MyBatis</a></li>
<li><a href="http://docs.jboss.org/hibernate/orm/4.2/manual/en-US/html/">Hibernate</a></li>
<li><a href="http://www.datanucleus.org/products/datanucleus/jdo/guides/tutorial_rdbms.html">JDO</a></li>
<li><a href="http://docs.oracle.com/javaee/6/tutorial/doc/bnbpz.html">JPA</a></li>
<li><a href="http://www.springsource.org/spring-data/jpa">Spring Data JPA</a></li>
</ul>


<p>Masing-masing memiliki kelebihan dan kekurangan masing-masing yang tidak akan kita bahas di artikel ini.
Kali ini kita hanya akan membahas metode Spring JDBC dan perbandingannya dengan JDBC murni.</p>

<p>Artikel ini merupakan bagian pertama dari rangkaian artikel Spring JDBC, yaitu</p>

<ol>
<li><a href="http://software.endy.muhardin.com/java/konfigurasi-koneksi-database-dengan-spring/">Konfigurasi koneksi database</a></li>
<li><a href="http://software.endy.muhardin.com/java/struktur-aplikasi-java-dengan-spring-dan-maven/">Struktur Aplikasi</a></li>
<li>Insert, update, dan delete data</li>
<li>Mengambil data (query)</li>
<li>Melakukan pengetesan</li>
</ol>


<p>Keseluruhan kode program dapat dilihat di <a href="https://github.com/endymuhardin/belajar-akses-database-java">repository belajar-akses-database-java di Github saya</a>, khususnya <a href="https://github.com/endymuhardin/belajar-akses-database-java/tree/spring-jdbc">branch spring-jdbc</a>.</p>

<!--more-->


<h2>Perbandingan JDBC polos dan Spring JDBC</h2>

<p>Menggunakan JDBC polos tanpa library memang mudah, karena tidak perlu pusing mempelajari library lain. Tapi ada beberapa keterbatasan dan kesulitan, diantaranya:</p>

<ul>
<li>semua method throws Exception, sehingga kode program kita menjadi kotor dengan try-catch</li>
<li>tidak ada manajemen koneksi database, kita harus buka-tutup sendiri</li>
<li>tidak ada declarative transaction, kita harus secara manual melakukan begin-commit/rollback</li>
</ul>


<p>Dengan berbagai keterbatasan tersebut, ada baiknya kita menggunakan bantuan Spring Framework, yaitu modul <code>spring-jdbc</code> untuk memudahkan berbagai kegiatan di atas. Tentunya masih banyak hal yang harus kita lakukan sendiri, tidak seperti penggunaan library Object Relational Mapping (ORM) seperti Hibernate atau JPA, di antaranya:</p>

<ul>
<li>mapping dari result set menjadi Java object</li>
<li>mapping dari Java object menjadi isi parameter PreparedStatement</li>
<li>cache</li>
<li>cascading operation</li>
<li>generate primary key secara otomatis</li>
<li>dsb</li>
</ul>


<p>Ada beberapa tahapan dalam menggunakan Spring JDBC, yaitu :</p>

<ol>
<li>Konfigurasi Koneksi Database</li>
<li>Membuat class Data Access Object (DAO)</li>
<li>Membuat class implementasi business process/service</li>
<li>Membuat test otomatis menggunakan JUnit</li>
</ol>


<h1>Studi Kasus</h1>

<p>Agar lebih konkrit, kita akan menggunakan skema database yang umum digunakan di aplikasi bisnis,
yaitu memiliki tabel :</p>

<ul>
<li>Master Data / Referensi</li>
<li>Header Transaksi</li>
<li>Detail Transaksi</li>
</ul>


<p>Berikut adalah skema database yang akan kita gunakan:</p>

<p>```sql
create table m_produk (</p>

<pre><code>id int primary key auto_increment,
kode varchar(20) not null,
nama varchar(255) not null,
harga decimal(19,2) not null
</code></pre>

<p>) engine=InnoDB ;</p>

<p>create table t_penjualan (</p>

<pre><code>id int primary key auto_increment,
waktu_transaksi datetime not null
</code></pre>

<p>) engine=InnoDB AUTO_INCREMENT=100;</p>

<p>create table t_penjualan_detail (</p>

<pre><code>id int primary key auto_increment,
id_penjualan int not null,
id_produk int not null,
harga decimal(19,2) not null,
jumlah int not null, 
foreign key(id_penjualan) references t_penjualan(id) on delete cascade,
foreign key(id_produk) references m_produk(id) on delete restrict
</code></pre>

<p>) engine=InnoDB AUTO_INCREMENT=100;
```</p>

<p>Untuk keperluan test, jangan lupa kita sertakan beberapa baris data.</p>

<p>```sql
insert into m_produk (id,kode,nama,harga) values
(1, 'K-001', 'Keyboard USB', 150000),
(2, 'M-001', 'Mouse USB', 50000),
(3, 'L-001', 'Laptop', 10000000);</p>

<p>insert into t_penjualan (id,waktu_transaksi) values
(1,'2013-01-01 20:30:30'),
(2,'2013-01-02 15:15:15'),
(3,'2013-02-02 09:09:09');</p>

<p>insert into t_penjualan_detail (id,id_penjualan, id_produk, harga, jumlah) values
(1,1,1,150000,2),
(2,1,2,50000,5),
(3,2,1,150000,3),
(4,2,2,50000,3),
(5,3,3,10000000,1);
```</p>

<p>Tabel dan data di atas kita masukkan ke database dengan rincian sebagai berikut:</p>

<ul>
<li>Jenis Database : MySQL</li>
<li>Server Database : localhost</li>
<li>Nama Database : belajar</li>
<li>Username Database : root</li>
<li>Password Database : admin</li>
</ul>


<p>Selanjutnya kita akan mengkonfigurasi Spring supaya bisa terkoneksi dengan database tersebut.</p>

<h1>Konfigurasi Koneksi Database</h1>

<h2>Dependensi</h2>

<p>Kita membutuhkan beberapa library, dinyatakan dalam dependensi Maven sebagai berikut:</p>

<h3>Driver database MySQL</h3>

<p>```xml
<dependency></p>

<pre><code>&lt;groupId&gt;mysql&lt;/groupId&gt;
&lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
&lt;version&gt;${mysql.version}&lt;/version&gt;
&lt;scope&gt;runtime&lt;/scope&gt;
</code></pre>

<p></dependency>
```</p>

<h3>Library manajemen koneksi database (database connection pooling)</h3>

<p>```xml
<dependency></p>

<pre><code>&lt;groupId&gt;commons-dbcp&lt;/groupId&gt;
&lt;artifactId&gt;commons-dbcp&lt;/artifactId&gt;
&lt;version&gt;${commons-dbcp.version}&lt;/version&gt;
</code></pre>

<p></dependency>
```</p>

<h3>Spring JDBC</h3>

<p>```xml
<dependency></p>

<pre><code>&lt;groupId&gt;org.springframework&lt;/groupId&gt;
&lt;artifactId&gt;spring-context&lt;/artifactId&gt;
&lt;version&gt;${org.springframework.version}&lt;/version&gt;
</code></pre>

<p></dependency></p>

<p><dependency></p>

<pre><code>&lt;groupId&gt;org.springframework&lt;/groupId&gt;
&lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;
&lt;version&gt;${org.springframework.version}&lt;/version&gt;
</code></pre>

<p></dependency></p>

<p><dependency></p>

<pre><code>&lt;groupId&gt;org.springframework&lt;/groupId&gt;
&lt;artifactId&gt;spring-test&lt;/artifactId&gt;
&lt;version&gt;${org.springframework.version}&lt;/version&gt;
&lt;scope&gt;test&lt;/scope&gt;
</code></pre>

<p></dependency>
```</p>

<p>Selanjutnya, kita membuat konfigurasi database untuk Spring. Kita beri nama saja file konfigurasinya <code>spring-jdbc-ctx.xml</code>
dan kita letakkan di folder <code>src/main/resources</code>. File ini berisi :</p>

<ul>
<li>konfigurasi data source untuk koneksi ke database. Kita menggunakan pustaka <code>commons-dbcp</code> untuk menangani connection pooling ke database.</li>
<li>transaction manager. Ini dibutuhkan supaya kita tidak perlu lagi membuat coding untuk rangkaian <code>begin-commit/rollback</code>.</li>
<li>component scan. Ini dibutuhkan agar object DAO dan Service kita otomatis dideteksi dan diinisialisasi oleh Spring</li>
</ul>


<h2>Koneksi Database</h2>

<p>Berikut konfigurasi koneksi database</p>

<p>```xml
<bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource"></p>

<pre><code>&lt;property name="driverClassName" value="com.mysql.jdbc.Driver" /&gt;
&lt;property name="url" value="jdbc:mysql://localhost/belajar" /&gt;
&lt;property name="username" value="root" /&gt;
&lt;property name="password" value="admin" /&gt;
&lt;property name="maxActive" value="80" /&gt;
&lt;property name="maxWait" value="40000" /&gt;
&lt;property name="maxIdle" value="20" /&gt;
</code></pre>

<p></bean>
```</p>

<p>Penjelasannya sebagai berikut:</p>

<h3>Database Connection Pooling</h3>

<p>Koneksi ke database sebetulnya merupakan operasi yang <em>mahal</em>. Kenapa <em>mahal</em>?
Karena setiap kali kita membuat koneksi, ada serangkaian kegiatan yang harus dilakukan oleh database server seperti:</p>

<ul>
<li>memeriksa username dan password</li>
<li>memeriksa apakah komputer kita (dilihat dari alamat IP atau nama host) diijinkan untuk masuk</li>
<li>memeriksa apakah database, tabel, dan tindakan yang kita lakukan memiliki ijin akses yang mencukupi</li>
</ul>


<p>Oleh karena itu, idealnya koneksi database dibuat sekali saja dan digunakan terus sepanjang aplikasi berjalan.
Tentunya kalau koneksi database hanya satu, setiap request dari user akan mengantri.
Untuk itu kita buat banyak koneksi sekaligus yang nantinya akan <em>dipinjamkan</em> pada request yang membutuhkan.
Teknik ini disebut dengan istilah database connection pooling.</p>

<p>Library yang kita gunakan untuk itu adalah <a href="http://commons.apache.org/proper/commons-dbcp/configuration.html">Apache Commons DBCP</a>, yang ditandai dengan penggunaan class <code>org.apache.commons.dbcp.BasicDataSource</code> di atas.</p>

<p>Ada banyak hal yang bisa disetting, tapi kita akan fokus ke beberapa saja yaitu:</p>

<ul>
<li><code>driverClassName</code> : nama class untuk koneksi ke database. Ini harus sesuai dengan merek dan versi database yang digunakan</li>
<li><code>url</code> : informasi koneksi database. Biasanya berisi alamat server (IP atau Hostname) dan nama database</li>
<li><code>username</code> : username untuk connect ke database</li>
<li><code>password</code> : passwordnya user tersebut</li>
</ul>


<p>Keempat informasi di atas adalah informasi umum yang kita butuhkan apapun metode koneksi database yang kita gunakan, tidak terkait dengan penggunaan Apache Commons DBCP. Konfigurasi berikut barulah berkaitan dengan Apache Commons DBCP:</p>

<ul>
<li><p><code>maxActive</code> : jumlah koneksi yang boleh aktif secara berbarengan. Ini harus disetting dibawah angka yang kita ijinkan di database server. Misalnya di MySQL kita ijinkan 100 koneksi berbarengan, maka angkanya harus dibawah 100. Jangan juga dihabiskan 100, untuk berjaga-jaga siapa tahu kita butuh koneksi langsung ke MySQL tanpa lewat aplikasi (misalnya untuk keperluan debug). Pertimbangkan juga apabila ada aplikasi lain yang menggunakan database yang sama.</p></li>
<li><p><code>maxIdle</code> : ada kalanya aplikasi kita sedang sepi dari request user sehingga banyak koneksi database yang menganggur (idle). Angka <code>maxIdle</code> ini menentukan berapa koneksi yang akan tetap dipegang walaupun idle. Bila ada 20 koneksi idle, padahal <code>maxIdle</code> berisi 15, maka 5 koneksi akan ditutup. Ini merupakan trade-off. Bila terlalu banyak idle, maka memori database server akan terpakai untuk koneksi yang standby ini. Tapi bila terlalu sedikit, pada waktu aplikasi mendadak diserbu user, akan butuh waktu lama untuk dia membuatkan lagi koneksi baru.</p></li>
<li><p><code>maxWait</code> : bila semua koneksi sebanyak <code>maxActive</code> sedang terpakai semua, request berikutnya akan menunggu salah satu selesai menggunakan koneksi. Nilai <code>maxWait</code> menentukan berapa milidetik request tersebut menunggu. Bila lebih dari <code>maxWait</code> dan belum juga kebagian koneksi, maka request tersebut akan mendapatkan <code>Exception</code>. Konfigurasi ini perlu diperhatikan karena nilai defaultnya adalah <code>indefinitely</code> yaitu menunggu selamanya.</p></li>
</ul>


<p>Saya pernah mendapatkan masalah karena setting default ini. Aplikasi bengong seolah hang. Dicek ke log file tidak ada error. Ternyata masalahnya ada query yang kurang optimal sehingga memakan waktu lama. Pada saat banyak request yang menjalankan query tersebut, request lain menunggu lama tanpa ada pemberitahuan, sehingga terkesan hang. Setelah nilai <code>maxWait</code> saya ganti menjadi 30 detik, mulai banyak error message bermunculan dari request yang menunggu > 30 detik. Dengan adanya error message, query bermasalah tersebut menjadi terlihat sehingga bisa diperbaiki.</p>

<p><blockquote><p>Pesan moral pertama : pesan error itu penting untuk mengetahui sumber masalah. Dalam bugfixing, yang paling penting adalah menemukan masalah. Kalau masalah sudah ditemukan, siapa saja bisa memperbaiki. Jadi kalau aplikasi kita bermasalah, prioritas pertama kita adalah membuat dia mengeluarkan pesan error yang jelas.</p></blockquote></p>

<p>Baca <a href="http://software.endy.muhardin.com/java/tips-melaporkan-error/">artikel ini</a> untuk mengetahui apa yang dimaksud dengan pesan error yang jelas.</p>

<p><blockquote><p>Pesan moral kedua : Dalam bugfixing, sering kali kita tidak langsung mendapatkan masalah utama. Pada kasus di atas, pertama kali saya menemukan bahwa perilaku defaultnya Commons DBCP adalah menunggu koneksi dengan sabar sampai selamanya. Setelah ini diubah, barulah saya menemukan masalah utama, yaitu ada query yang tidak optimal.</p></blockquote></p>

<h2>Transaction Manager</h2>

<p>Setelah terhubung ke database, selanjutnya kita akan mengkonfigurasi transaction manager. Ini adalah fitur dari Spring Framework yang membebaskan kita dari coding manual untuk urusan transaction. Bila tidak menggunakan ini, maka kode program kita akan tampak seperti ini:</p>

<p>```java
public void simpan(Produk p){</p>

<pre><code>Connection conn; // inisialisasi koneksi di sini

try {
    conn.setAutocommit(false);

    String sql = "insert into m_produk ... ";
    conn.createStatement().executeUpdate(sql);

    conn.commit();

} catch (Exception err){
    conn.rollback();
} finally {
    conn.setAutocommit(true);
    conn.close();
}
</code></pre>

<p>}
```</p>

<p>Untuk dua baris perintah seperti di atas, kita harus menambahkan 8 baris hanya untuk mengurus transaction <strong>pada setiap method</strong>. Bayangkan kalau aplikasi kita punya 100 method, maka kode program untuk mengelola transaksi saja sudah 800 baris. Dengan fitur transaction manager, maka method di atas bisa ditulis ulang seperti ini:</p>

<p>```java
@Transactional
public void simpan(Produk p){</p>

<pre><code>String sql = "insert into m_produk ... ";
conn.createStatement().executeUpdate(sql);
</code></pre>

<p>}
```</p>

<p>Jauh lebih bersih dan rapi. Kode program jadi mudah dibaca dan akibatnya tentu memudahkan kita pada waktu bugfix, perubahan, ataupun penambahan fitur.</p>

<p>Nah ini dia konfigurasi transaction manager:</p>

<p>```xml
<bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"></p>

<pre><code>&lt;property name="dataSource" ref="dataSource"/&gt;
</code></pre>

<p></bean></p>

<p>&lt;tx:annotation-driven/>
```</p>

<p>Class transaction manager yang digunakan berbeda tergantung metode akses database yang digunakan dan juga bagaimana cara kita mendeploy aplikasi. Beberapa pilihan transaction manager yang lain antara lain:</p>

<ul>
<li><code>DataSourceTransactionManager</code> : digunakan untuk koneksi database menggunakan <code>javax.sql.DataSource</code>. Ini artinya koneksi langsung dari aplikasi ke database server.</li>
<li><code>JtaTransactionManager</code> : digunakan bila aplikasi kita dideploy di application server yang memiliki transaction manager sendiri (seperti Glassfish, JBoss, Websphere, Weblogic, dsb) <em>dan menggunakan</em> transaction manager yang disediakan tersebut. Bila kita deploy di Tomcat, hampir pasti kita tidak menggunakan JTA. Bila kita deploy ke Glassfish dan menggunakan konfigurasi <code>dataSource</code> Apache Commons DBCP, berarti kita juga tidak menggunakan JTA.</li>
<li><code>HibernateTransactionManager</code> : seperti ditunjukkan oleh namanya, gunakan ini bila kita menggunakan Hibernate</li>
<li><code>JpaTransactionManager</code> : ini juga sudah jelas dari namanya. Bila kita pakai JPA, gunakan transaction manager ini.</li>
</ul>


<p>Demikian tutorial cara konfigurasi koneksi database. Pada bagian selanjutnya, kita akan <a href="http://software.endy.muhardin.com/java/struktur-aplikasi-java-dengan-spring-dan-maven/">menyiapkan kerangka aplikasinya dulu</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mendebug Aplikasi AJAX]]></title>
    <link href="http://software.endy.muhardin.com/java/mendebug-aplikasi-ajax/"/>
    <updated>2013-05-22T16:46:00+07:00</updated>
    <id>http://software.endy.muhardin.com/java/mendebug-aplikasi-ajax</id>
    <content type="html"><![CDATA[<p>Di jaman modern ini, penggunaan AJAX sudah sangat mendunia, sehingga jarang sekali kita temui aplikasi yang tidak menggunakan AJAX. Demikian juga dengan template aplikasi standar yang digunakan di ArtiVisi, yaitu <a href="https://github.com/endymuhardin/belajar-restful">Belajar RESTful</a>.</p>

<p>Bagi yang baru mendengar atau sering dengar tapi belum paham, berikut penjelasan singkat mengenai AJAX.</p>

<ul>
<li>AJAX adalah salah satu teknik pemrograman web</li>
<li>AJAX bukanlah nama library atau framework, dia adalah cara membuat aplikasi</li>
<li><p>Pada aplikasi non-AJAX, siklusnya sebagai berikut :</p>

<ol>
<li>Ketik URL</li>
<li>Tampil HTML</li>
<li>Lakukan sesuatu (isi form + tekan submit)</li>
<li>Browser mengirim data</li>
<li>Server mengembalikan HTML full satu halaman</li>
</ol>
</li>
<li><p>Pada aplikasi AJAX, request ke server dilakukan oleh javascript, bukan oleh form submit.</p></li>
<li>Response dari server biasanya hanya berupa data dalam format XML atau JSON, bukan data + tampilan seperti HTML</li>
<li>Data yang dikirim server digunakan javascript hanya untuk mengubah sebagian halaman tampilan, bukan seluruh halaman seperti aplikasi non-AJAX.</li>
</ul>


<p>Karena perbedaan cara kerja aplikasi AJAX, maka cara debug errornya juga berbeda. Untuk mendebug aplikasi AJAX, kita perlu melengkapi browser yang kita gunakan supaya bisa memantau request dan response yang dilakukan aplikasi.</p>

<p>Pada artikel ini, kita akan membahas bagaimana cara mendebug aplikasi AJAX. Sebagai contoh kasus, kita akan gunakan aplikasi <a href="https://github.com/endymuhardin/belajar-restful">Belajar RESTful</a>.</p>

<!--more-->


<h2>Studi Kasus</h2>

<p>Sebagai contoh, kita akan mendebug form entri user berikut</p>

<p><img src="/images/uploads/2013/05/debug-ajax/01-screen-form-user.png" title="Form Entri User" ></p>

<p>dan tampilan daftar user berikut</p>

<p><img src="/images/uploads/2013/05/debug-ajax/02-screen-list-user.png" title="Daftar User" ></p>

<h2>Persenjataan</h2>

<p>Agar bisa mendebug aplikasi AJAX, browser kita harus bisa menampilkan lalu lintas request dan response. Bila menggunakan Firefox, instal plugin <a href="https://addons.mozilla.org/en-US/firefox/addon/firebug/">Firebug</a>. Bila menggunakan Chrome, kemampuan ini sudah ada di menu Tools > Developer Tools sehingga kita tidak perlu menginstal apa-apa.</p>

<p>Setelah terinstal, pantau tab Network untuk melihat detail request dan response.</p>

<p>Berikut contohnya di Firebug</p>

<p><img src="/images/uploads/2013/05/debug-ajax/03-network-tab-firebug.png" title="Network Tab Firebug" ></p>

<p>Dan ini tampilannya di Chrome Developer Tools</p>

<p><img src="/images/uploads/2013/05/debug-ajax/04-network-tab-chrome.png" title="Network Tab Chrome Developer Tools" ></p>

<p>Seiring waktu, tab ini bisa penuh, kita bisa bersihkan menggunakan tombol Clear.</p>

<p><img src="/images/uploads/2013/05/debug-ajax/05-clear-log.png" title="Tombol Clear" ></p>

<p>Beberapa aplikasi AJAX yang mengikuti kaidah REST mengirim data ke server dalam format JSON dengan HTTP method yang sesuai fungsi seperti GET, POST, PUT, DELETE. Seringkali kita juga perlu memanipulasi HTTP request header dan melihat isi HTTP response header. Untuk itu, kita perlu menambah plugin lagi di browser.</p>

<p>Silahkan install <a href="https://addons.mozilla.org/En-us/firefox/addon/poster/">Poster</a> untuk Firefox, atau <a href="https://chrome.google.com/webstore/detail/rest-console/cokgbflfommojglbmbpenpphppikmonn?hl=en">Rest Console</a> untuk Chrome.</p>

<h2>Mendebug Form Submit</h2>

<p>Di aplikasi Belajar RESTful, ketika kita mengisi form dan menekan tombol Simpan, prosesnya agak berbeda dengan aplikasi web tradisional.
Pada aplikasi ini, semua form data dikumpulkan dan dikonversi menjadi format JSON, dan kemudian dikirim dalam HTTP request body. Ini dilakukan menggunakan Javascript.</p>

<p>Di aplikasi web tradisional, data form ini disubmit dalam format HTTP request parameter dan tidak melibatkan Javascript sama sekali.</p>

<p>Karena ada proses konversi menjadi JSON ini, selama proses development kita ingin melihat dan memeriksa apakah nama variabel dan datanya sudah benar. Untuk itu kita bisa menggunakan Chrome Developer Tools, seperti bisa dilihat di screenshot berikut.</p>

<p><img src="/images/uploads/2013/05/debug-ajax/06-debug-siklus-cdt.png" title="Debug Request di Chrome Developer Tools" ></p>

<p>Screen debug di Firebug bentuknya seperti ini</p>

<p><img src="/images/uploads/2013/05/debug-ajax/09-debug-siklus-firebug.png" title="Debug Request di Firebug" ></p>

<p>Hal-hal yang perlu kita amati adalah :</p>

<ul>
<li><p>Request</p>

<ul>
<li>Request Method : GET, POST, PUT, atau DELETE</li>
<li>Request Header, terutama Accept dan Content-Type</li>
<li>Request Parameter</li>
<li>Data yang dikirim (bila ada)</li>
</ul>
</li>
<li><p>Response</p>

<ul>
<li>Response Status : Sukses (200, 201, 204) atau Gagal (4xx atau 5xx)</li>
<li>Response Header, terutama Content-Type dan Location</li>
<li>Response Data (bila ada)</li>
</ul>
</li>
</ul>


<p>Berikut adalah data-data tersebut di Chrome Developer Tools</p>

<p><img src="/images/uploads/2013/05/debug-ajax/07-detail-request-cdt.png" title="Detail Request Chrome Developer Tools" ></p>

<p><img src="/images/uploads/2013/05/debug-ajax/08-detail-response-cdt.png" title="Detail Response Chrome Developer Tools" ></p>

<p>Di Firebug, header dan data dipisahkan</p>

<p><img src="/images/uploads/2013/05/debug-ajax/10-detail-request-firebug.png" title="Tab Header" ></p>

<p>Request data ditampilkan di tab terpisah</p>

<p><img src="/images/uploads/2013/05/debug-ajax/11-detail-post-data-firebug.png" title="Tab Request Data" ></p>

<p>Pada waktu membaca data response, kita bisa melihat data aslinya</p>

<p><img src="/images/uploads/2013/05/debug-ajax/12-detail-response-firebug.png" title="Detail Response Firebug" ></p>

<p>dan bisa juga melihat yang sudah diformat dengan rapi</p>

<p><img src="/images/uploads/2013/05/debug-ajax/13-detail-json-firebug.png" title="Detail JSON Firebug" ></p>

<h2>Mendebug REST Server</h2>

<p>Pada waktu kita mengisi form dan menekan tombol Submit, client mengirim HTTP request dan data berbentuk JSON. Kemudian server memproses data yang diterima dan mengirim kembalian berupa JSON juga. Agar development lebih mudah, kita ingin melakukan request dan melihat response secara langsung, tanpa direpotkan dengan tampilan HTML dan coding Javascript. Kita bisa menggunakan plugin browser untuk melakukan hal ini.</p>

<p>Beberapa hal yang harus kita ketahui untuk mengetes proses di sisi server adalah:</p>

<ul>
<li>URL</li>
<li>HTTP Method</li>
<li>Tipe data yang dikirim</li>
<li>Data yang akan dikirim</li>
</ul>


<h3>Menggunakan Chrome</h3>

<p>Berikut adalah tampilan plugin Chrome, yaitu REST Console yang sudah terisi data di atas.</p>

<p><img src="/images/uploads/2013/05/debug-ajax/14-request-form-rest-console.png" title="Request Form REST Console" ></p>

<p>Selanjutnya kita tinggal menekan tombol yang sesuai dengan HTTP Method yang dibutuhkan. Bila sukses, kita akan mendapatkan tampilan seperti ini</p>

<p><img src="/images/uploads/2013/05/debug-ajax/15-response-sukses-rest-console.png" title="Response Sukses REST Console" ></p>

<p>Bila gagal, kita akan melihat tampilan seperti ini</p>

<p><img src="/images/uploads/2013/05/debug-ajax/16-response-error-rest-console.png" title="Response Gagal REST Console" ></p>

<h3>Menggunakan Firefox</h3>

<p>Hal yang sama bisa dilakukan dengan Poster di Firefox. Berikut adalah form yang digunakan untuk entri data.</p>

<p><img src="/images/uploads/2013/05/debug-ajax/17-request-form-poster.png" title="Request Form Poster" ></p>

<p>Bila sukses, kita mendapatkan hasil seperti ini</p>

<p><img src="/images/uploads/2013/05/debug-ajax/18-response-sukses-poster.png" title="Response Sukses Poster" ></p>

<p>Bila gagal berikut tampilannya</p>

<p><img src="/images/uploads/2013/05/debug-ajax/19-response-error-poster.png" title="Response Gagal Poster" ></p>

<p>Dengan menggunakan REST Console dan Poster, kita dapat mengurus coding di sisi server tanpa perlu dipusingkan dengan coding di sisi client (HTML, CSS, dan JS).</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Integrasi Aplikasi]]></title>
    <link href="http://software.endy.muhardin.com/java/integrasi-aplikasi/"/>
    <updated>2013-05-20T21:20:00+07:00</updated>
    <id>http://software.endy.muhardin.com/java/integrasi-aplikasi</id>
    <content type="html"><![CDATA[<p>Aplikasi jaman sekarang jarang sekali yang berdiri sendiri.
Umumnya aplikasi yang kita buat harus terhubung dengan aplikasi yang dibuat orang lain.
Beberapa contohnya:</p>

<ul>
<li>kita membuat aplikasi mobile, terhubung ke social network seperti Facebook dan Twitter</li>
<li>kita membuat aplikasi bisnis, harus terhubung ke aplikasi akunting yang sudah lebih dulu ada</li>
<li>kita membuat aplikasi pembayaran tagihan, harus terhubung ke penyedia tagihan seperti PLN, Telkom, dsb</li>
</ul>


<p>Pada artikel ini, kita akan membahas beberapa strategi untuk menghubungkan aplikasi yang kita buat dengan aplikasi lain.</p>

<!--more-->


<p>Secara umum, ada empat strategi untuk menghubungkan aplikasi satu dengan lainnya:</p>

<ul>
<li>pemanggilan prosedur/function</li>
<li>messaging</li>
<li>sharing database</li>
<li>kirim/terima file</li>
</ul>


<p>Mari kita bahas satu persatu.</p>

<h2>Pemanggilan prosedur</h2>

<p>Pada metode ini, aplikasi yang akan melayani (kita sebut aplikasi server),
harus menyediakan mekanisme agar bisa dipanggil aplikasi lain (kita sebut aplikasi client).</p>

<p>Ada beberapa protokol yang populer digunakan dalam strategi ini, misalnya:</p>

<ul>
<li>SOAP</li>
<li>REST</li>
<li>ISO-8583</li>
<li>XMLRPC</li>
</ul>


<p>Ciri utama dalam strategi ini adalah:</p>

<ul>
<li>ada kesepakatan nama method yang akan dipanggil</li>
<li>ada kesepakatan jumlah dan tipe data yang dikirim dan diterima</li>
<li>client dan server harus online dalam waktu yang berbarengan.</li>
<li>setelah client memanggil server, dia akan menunggu sampai ada balasan dari server. Sebelum terima balasan, client tidak bisa melanjutkan. Fenomena ini dikenal dengan istilah synchronous invocation.</li>
</ul>


<p>Berikut beberapa contoh implementasi dari strategi ini:</p>

<ul>
<li><a href="http://software.endy.muhardin.com/java/remoting-dengan-spring/">Remoting dengan Spring Framework</a></li>
<li><a href="http://martinusadyh.web.id/tulisanku/berkenalan-dengan-iso-8583-menggunakan-java/">Transaksi Finansial dengan ISO-8583</a></li>
</ul>


<h2>Messaging</h2>

<p>Konsep messaging sebetulnya sudah tidak asing lagi bagi kita. Sering kita gunakan sehari-hari dalam bentuk email, chatting, sms, dan sejenisnya.</p>

<p>Beberapa ciri dari messaging antara lain:</p>

<ul>
<li>pengirim dan penerima tidak harus online berbarengan. Bisa saja pengirim mengirim pesan pada saat penerima offline, setelah itu pengirim juga offline. Pada waktu penerima online, dia akan menerima pesan yang ditujukan kepadanya pada waktu dia sedang offline.</li>
<li>ada satu pihak yang berfungsi sebagai penyimpan message. Dalam dunia messaging, pihak ini disebut sebagai message broker.</li>
<li>karena sifatnya yang memungkinkan tidak online barengan, maka biasanya ada mekanisme status delivery</li>
<li>biasanya ada juga masa kadaluarsa message di dalam database broker. Sebagai contoh, bila handphone kita mati lebih dari tiga hari, maka sms yang ditujukan ke handphone tersebut dan belum sampai di handphone kita akan dihapus oleh operator telekomunikasi.</li>
<li>tidak ada aturan mengenai format dan tipe data. Pengirim bebas mengirim apa saja. Penerima yang harus melakukan validasi terhadap format message</li>
<li>tidak ada mekanisme notifikasi ketika ada message baru. Penerima harus secara periodik mengecek (polling) ke broker untuk mengetahui ada-tidaknya message baru</li>
</ul>


<p>Dalam Java, ada beberapa pilihan untuk implementasi strategi messaging, diantaranya:</p>

<ul>
<li><a href="http://software.endy.muhardin.com/java/integrasi-pusat-cabang-2/">melalui email</a></li>
<li><a href="http://www.playsms.org/">melalui sms</a></li>
<li><a href="http://software.endy.muhardin.com/java/intro-jms/">menggunakan protokol JMS</a></li>
<li>menggunakan protokol AMQP</li>
</ul>


<h2>Sharing Database</h2>

<p>Pada strategi ini, pengirim dan penerima menggunakan database sebagai media pertukaran data. Pengirim menaruh datanya ke suatu tabel di database untuk kemudian dibaca oleh penerima.</p>

<p>Karena menggunakan database, maka mekanisme ini memiliki beberapa ciri khusus interaksi dengan database, yaitu:</p>

<ul>
<li>transaction. Pengirim bisa memastikan datanya terkirim secara utuh. Bila terjadi error di tengah pengiriman data, maka data yang sudah terlanjur ditulis bisa dibatalkan</li>
<li>tipe data bisa di-enforce. Kita bisa menggunakan tipe data angka, text, dan tanggal. Bila pengirim salah memasukkan data, maka database server akan menolaknya.</li>
</ul>


<p>Mirip dengan messaging, tidak ada mekanisme notifikasi ketika ada data baru yang ditaruh pengirim. Penerima harus secara periodik mengecek (polling) ke database untuk mengetahui ada-tidaknya data baru. Untuk memudahkan polling, biasanya tiap data diberikan kolom status untuk membedakan mana data yang sudah diproses dan mana yang belum.</p>

<p>Bila kita menggunakan Spring Integration, kita bisa langsung menggunakan <a href="http://static.springsource.org/spring-integration/reference/htmlsingle/#jdbc">implementasi yang tersedia</a> sehingga tidak perlu lagi membuatkan mekanisme pengecekan data baru. <a href="https://github.com/SpringSource/spring-integration-samples/tree/master/basic/jdbc">Contoh pemakaian juga sudah disediakan</a>, tinggal diikuti.</p>

<h2>File Transfer</h2>

<p>Sama seperti messaging, dengan strategi ini pengirim dan penerima tidak harus online berbarengan. Yang membedakannya dengan messaging adalah pada mekanisme ini biasanya format file dan struktur data di dalamnya sudah ditentukan. Demikian juga dengan lokasi penyimpanan file dan aturan penamaannya.</p>

<p>Berbeda dengan sharing database, mekanisme file transfer tidak memiliki mekanisme untuk memastikan data sampai dengan utuh. Kita sendiri yang harus memastikan keutuhan data, misalnya dengan mengirim file checksum bersama dengan file berisi data. File checksum ini bisa digunakan untuk memastikan file data terkirim secara utuh.</p>

<p>Pada mekanisme ini kita juga tidak bisa tahu progress pengiriman data. Apakah pengirim masih dalam proses mengirim atau sudah selesai? Kita tidak tahu secara pasti. Biasanya diakali dengan cara memeriksa ukuran file dalam selang waktu tertentu. Bila ukurannya masih terus bertambah, berarti proses pengiriman masih berjalan. Bila ukurannya tidak membesar lagi, ada indikasi bahwa pengiriman sudah selesai.</p>

<p>Untungnya prosedur pengecekan ini sudah dibuatkan <a href="http://static.springsource.org/spring-integration/reference/htmlsingle/#files">implementasinya</a> oleh rekan-rekan Spring Integration, sehingga kita tinggal mengikuti <a href="https://github.com/SpringSource/spring-integration-samples/tree/master/basic/file">contoh yang tersedia</a>.</p>

<p>Demikianlah sedikit informasi mengenai integrasi antar aplikasi. Semoga bermanfaat :)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mencari Relasi Foreign Key ke Tabel MySQL]]></title>
    <link href="http://software.endy.muhardin.com/java/mencari-relasi-foreign-key-ke-tabel-mysql/"/>
    <updated>2013-02-07T15:24:00+07:00</updated>
    <id>http://software.endy.muhardin.com/java/mencari-relasi-foreign-key-ke-tabel-mysql</id>
    <content type="html"><![CDATA[<p>Di aplikasi yang kita buat, biasanya ada fitur untuk menghapus data atau record tertentu.
Bila kita menggunakan database relasional yang memiliki fitur <em>referential integrity</em>,
kita akan dicegah bila data yang ingin kita hapus memiliki relasi ke data lain.</p>

<p>Contohnya, kita punya tabel <code>Produk</code>, yang kolom <code>id</code>nya digunakan sebagai <em>foreign key</em>
oleh tabel <code>Penjualan</code>.
Dengan demikian, pada waktu ingin menghapus data <code>Produk</code>, terlebih dulu kita cek ke tabel
<code>Penjualan</code>, apakah ada data transaksi yang berelasi ke <code>Produk</code> yang ingin kita hapus.</p>

<p>Akan menjadi masalah bila aplikasi kita sudah besar, tabelnya ada ratusan.
Bagaimana cara kita mencari tabel mana saja yang memiliki relasi ke tabel <code>Produk</code>?
Tentunya tidak mungkin dicek satu-persatu.</p>

<p>Dengan bantuan paman Google, berikut adalah cara mendapatkannya untuk database MySQL.</p>

<!--more-->


<p>Pertama, login dulu ke MySQL</p>

<p><code>
mysql -u root -p
Password:
mysql&gt;
</code></p>

<p>Kemudian, gunakan database <code>information_schema</code></p>

<p><code>
use information_schema
</code></p>

<p>Terakhir, jalankan query SQL berikut</p>

<p><code>sql
SELECT TABLE_NAME,COLUMN_NAME,CONSTRAINT_NAME,
REFERENCED_TABLE_NAME,REFERENCED_COLUMN_NAME
FROM KEY_COLUMN_USAGE
WHERE REFERENCED_TABLE_NAME = 'produk'
AND REFERENCED_COLUMN_NAME = 'id'
AND TABLE_SCHEMA='db_penjualan';
</code></p>

<p>Inilah hasilnya</p>

<p><code>
+-------------------------------------------------------------------------------------------+
| TABLE_NAME         | COLUMN_NAME | CONSTRAINT_NAME     | REFERENCED_TABLE_NAME | REFERENCED_COLUMN_NAME |
+-------------------------------------------------------------------------------------------+
| penjualan          | id_produk   | fk_penjualan_produk | produk                | id                     |
| stok               | id_produk   | fk_stok_produk      | produk                | id                     |
+-------------------------------------------------------------------------------------------+
</code></p>

<p>Penjelasan:</p>

<ul>
<li>Table Name : Nama Tabel yang memiliki referensi</li>
<li>Column Name : Nama Kolom yang merupakan <em>foreign key</em></li>
<li>Constraint Name : Nama constraint <em>foreign key</em></li>
<li>Referenced Table Name : Nama tabel yang dituju</li>
<li>Referenced Column Name : Nama kolom yang dituju <em>foreign key</em></li>
</ul>


<p>Demikian sekilas tutorial. Semoga bermanfaat dalam membuat validasi.</p>
]]></content>
  </entry>
  
</feed>
